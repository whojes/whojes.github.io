I"<ol>
  <li>bash 스크립트 중 parameter 인풋이 없으면 default 로 설정하는 명령어</li>
</ol>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">[</span> <span class="nt">-z</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="o">]</span> <span class="k">then
    </span>version <span class="o">=</span> <span class="s2">"default"</span>
<span class="k">else
    </span>version <span class="o">=</span> <span class="nv">$1</span>
<span class="k">fi 
</span>대충 이럴텐데 <span class="o">(</span>테스트는 안해봄<span class="o">)</span>,
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>version <span class="o">=</span> <span class="k">${</span><span class="p">@</span><span class="k">:-</span><span class="nv">default</span><span class="k">}</span>
</code></pre></div></div>

<p>그냥 이렇게 쓰면 된단다. 나참…. 문법이 으이구 이걸 어떻게 알아보나이거 배쉬놈들</p>

<p>​</p>

<ol>
  <li>bash 문법은 if 조건문을 사용할 때</li>
</ol>

<p>if [ A == B ] 
if [ C != D ]
이게 아니라</p>

<p>if [ A -eq B ]
if [ C -ne D ] 
이렇게 써야한다. 이런 예시는 좀 빡치지만 (bash 를 잘 안쓰면 쓸 때마다 검색해야하게만든다) , 저런 기조를 유지함으로써 훨씬 더 많은 비교 및 조사를 할 수 있게 되는 것 같다.</p>

<p>[ -d ] : 파일이 디렉토리면 
[ -e ] : 파일이 있으면 참
[ -L ] : 파일이 심볼릭 링크면 참
[ -r ] : 파일이 읽기 가능하면 참
[ -s ] : 파일의 크기가 0 보다 크면 참
[ -w ] : 파일이 쓰기 가능하면 참
[ -x ] : 파일이 실행 가능하면 참
[ 파일1 -nt 파일2 ]  : 파일1이 파일2보다 최신파일이면 참
[ 파일1 -ot 파일2 ]  : 파일1이 파일2보다 이전파일이면 참
[ 파일1 -ef 파일2 ] : 파일1이 파일2랑 같은 파일이면 참 
출처: https://jink1982.tistory.com/48 [돼민이]
등의 수많은 variation 이 가능하다. 이러면 단순히 같다를 ==로 하게 되면 통일성이 떨어지겠지</p>

<p>​</p>

<ol>
  <li>xargs</li>
</ol>

<p>xargs 를 얼마나 잘 활용하는가 하는게 이사람이 쫌 간지나는 사람이구나를 판별하는 척도로 사용할 수 있겠다.</p>

<p>딱히 bash 랑만 관계있는건 아니지만, bash를 거의 사용하니까…</p>

<p>사실 대부분 $(명령어) 를 이용해서도 가능하긴 하지만, -0 옵션같은 유용한 사용법이 있어 더 안전하다.</p>

<p>ls -al $(find . -name “*.py”) 
는 모든 py 스크립트를 찾기에 간편하지만, 파일 이름에 공백이나 다른 특수문자가 있을 경우 명령어 전체에서 에러가 난다. stdout 도 꼬이고 echo $?로 ec를 확인해봐도 1이 나온다. 이를 방지하기 위해</p>

<p>find . -name “*.py” -print0 | xargs -0 ls -al
이런식으로 사용하면 된다. find 의 -print0 옵션은 결과 사이를 개행문자가 아닌 널문자로 구분하도록 stdout 을 내보내는 역할을 하고,  xarg의 -0옵션은 공백이 아닌 널문자로 인풋파라미터를 구분하도록 하는 옵션이다. man xargs 를 보면 알겠지만 -0 옵션 자체가 find 의 print0에 대응되도록 만들어졌다.</p>

<p>​</p>

<ol>
  <li>awk</li>
</ol>

<p>아… awk…. 뭔가 웹크롤링할때처럼  text 파일들이나 df, fdisk, lshw 등 명령어의 output을 크롤링할때 많이 써서 보기만해도 기분나쁘다.</p>

<p>그냥… 잘 쓰면 좋은데 그냥 기분나쁘다.</p>

<p>잘 정리된 블로그가 있어 참조한다.</p>
:ET
{"0": {
    "doc": "api 최적화와 gzip",
    "title": "api 최적화와 gzip",
    "content": "많은 서버에서 여러가지 이유로 중복해서 호출이 일어나는 api 가 있었다. 사실 그러라고 만들어 놓은 api 이기도 했지만, data center squeeze 테스트를 위해 트래픽을 한 쪽에 몰아 넣은 상황에서 uv 가 50k 정도 되었을 때 문제가 발생했다. 머신난이었던 때 인스턴스를 너무 많이 띄우는 괴물 아니냐는 말과 함께 로직에 최적화가 되어있는게 맞는 것인지 하는 챌린지가 많이 들어왔었다. 그래서, 다방면으로 이유를 분석해서 수정을 진행했다. 훌륭한 분들이 많이 봐주시고 해결해 주신 것도 많고 배운 것도 많고 해서 효과가 좋았던 것들을 몇개 정리하기로 했다. tps 15k . contents . | redis cache 사이즈 줄이기 | mongos 이슈들 | application 로직 최적화 | gzip | . redis cache 사이즈 줄이기 . | why . | 콜 수도 많고 몽고 서치/cpu 작업도 커서 레디스 캐싱을 해두었는데, redis 쪽으로 네트워크 bandwidth가 너무 컸다. 네크워크 비용도 아깝고 언젠가는 문제가 됐을 수 있어서 수정했다. | . | how . | 시리얼라이저를 바꿈 . | 레디스 넣기 전에 snappy 를 사용했는데, gzip 으로 바꿨음 snappy vs gzip | . | 캐싱 데이터를 바꿈 . | 특정 작업의 결과물을 캐싱하던 것에서, 사용되는 파라미터 중 변동되는 것만 캐싱하고 서버가 작업을 매번 새로 하게 함 | . | . | result . | 두 작업 모두 cpu 를 손해보고 network 를 이득보는 작업이라, 효과는 확실했다. 레디스 인아웃은 500 MiB/s -&gt; 95 MiB/s 로 감소했지만, api 응답은 p50 7.5ms -&gt; 12ms, p95 28ms -&gt; 32ms 로 증가했다. | . | . 레디스 네트워크 in/out. 첫 드랍은 snappy -&gt; gzip, 두번째 드랍은 캐싱데이터 수정 . 수정 후 전날과 응답속도 비교. 연산작업의 최적화가 필요해보인다. mongos 이슈들 . | mongos command max response 가 이상한 주기성을 가지고 늘어났음 uv 가 높은 상황에서, mongos 별로 주기적으로 max response 가 증가하는 피크가 관측됨 . | why . | mongos 로그 중 LockBusy: could not acquire collection lock for ${dbName}.${collectionName} to split chunk를 발견 (관련 이슈) | 해당 command 가 날아가는 collection 은 5.7b 개의 다큐먼트를 들고 있고, 인서트도 활발히 일어나는 컬렉션이었다. insert 후에 chunk split 하던 와중 분산락을 획득하는 과정이 있는데, 이게 이슈가 있다고 리포트가 되었음 | . | how . | mongos 버전을 업데이트하는 것으로 해결. | . | result . | 해결됨. 그러나… | . | . | 3개의 mongos 중 두개가 갑자기 죽었음 . | why . | mongos 버전을 업데이트 하면서, 메모리 증설을 위해 dc 타겟을 바꾸고 호스트를 변경했었는데, 카나리 배포과정에서 몽고 커넥션 수가 호스트의 pid_max 값을 초과했음 | 두개의 mongos 의 pid_max 값이 리눅스 system default 값이었고(32768), 기존 mongos 는 4백만 정도로 세팅을 해서 사용중이었다. root@32899a32399f:/# cat /proc/sys/kernel/pid_max 32768 . | 참으로 운이 좋게 같은 세팅값의 세번째 mongos 는 살아있어서, mongos1,2 으로 타임아웃이 잠깐 난 후에 mongos3 으로 이용하였으나 아찔했던 상황 | . | how . | max_pid 값 늘림 cat /etc/sysctl.d/91-mongos.conf | grep kernel_pid_max kernel_pid_max=4194303 . | . | result . | 해결됨 | . | . | 샤드 추가 . | why . | batch insert 시에 큰 도움이 된다. | 부하시간 대에 혹시나 swap 메모리로 가게 되면 리스폰스 타임에 문제가 갈 수 있고, 커넥션 타임아웃이 나고, 리스폰스 타임아웃이 나고, 이곳 저곳이 터지고… | . | how . | mongo cluster 에 샤드 하나를 추가했다. 총 3개가 됐다. 내가 한 건 아니지만… 공식 가이드 | 유휴시간에만 rebalance 를 돌리도록 해두었는데, 10b 가 넘어가는 총 다큐먼트 때문에 리밸런스 완료는 요원한 상황이다. | . | . | 기타 . | 다큐먼트 n 개 짜리 컬렉션 서치 시에 in 절에 m 개의 밸류를 넣으면 O(m*log(n)) 만큼 걸린다. 그러나, 인덱스 서치속도가 그렇다는 것이고 어쨌든 disk io 때문에 커맨드 리스폰스 자체는 m 에 리니어하게 증가하여 훨씬 더 길어질 수가 있다. 그런 경우에, 서치 시에 프로젝션을 줘서 인덱스에 포함된 필드만을 가져오게 한다면 추가적인 disk io 가 발생하지 않기 때문에 큰 이득을 볼 수 있다. 물론 다큐먼트 5.7b 짜리 컬렉션에 필드 3개짜리 컴파운드 인덱스를 추가한다? 허허.. | . | . application 로직 최적화 . | 사전작업 . | API 를 목적에 맞게 전부 분리함 . | 하나의 api 가 여러 목적에 대해 작업을 해주고 있었다. 처음에는 하나의 목적이었으나, uv 가 늘어나면서 점점 목적이 추가가 됐는데, 이로 인해 메트릭을 분석하기가 어려웠다. | 별도의 처리 없이 계산만 하여 return 하는 api | 모든것을 처리하고 계산하여 return 하는 api | 급한것만 처리하고 계산하여 return 하는 api | user 정보를 업데이트하고 계산하여 return 하는 api | . 를 분리하고 목적에 맞게 메트릭을 추가하여 분석하기 시작했다. | . | mongo 메트릭 추가 . | 몽고를 쓰던 곳이 많지 않아 common prometheus 작업이 될 때 몽고쪽은 메트릭 추가가 되지 않았었다. 따로 커맨드리스너를 추가하여 메트릭을 수집하기 시작했고, promql 으로 메트릭을 그리기 시작했다. | . | . | mongo search 를 최대한으로 줄였음 . | 딱히 이유가 없고 했었어야 하는 개선인데, 변명해보자면, 모듈화가 꽤 잘 되어있는 api 였기에 몽고 서치가 꽤 자주 일어났다. 말하자면.. msa 구조의 시스템에서 하나의 api 스트림에서 거쳐가는 서버 모두가 유저정보를 필요로 해서 각자가 했던 유저서버를 호출하고 또 호출하게 되는… 그런… 비슷한 문제라고 생각을 하는데, (netflix 에서는 passport를 이용해 문제를 해결했다. 유저 정보를 REST 헤더에 넣어서 계속 사용) 뭐 어쨌거나 이건 단일 서버 내에서 문제고 구조를 꽤 수정하여 최대한 한 번 했던 몽고서치는 다시 하지 않도록 수정했다. | . | . mongo call 개선 이후 call count . | mongo insert 작업을 병렬처리하였음 . | 오랜만에 접속한 유저는 많은 수의 insert 가 일어나게 돼서, 이를 줄이기 위해 병렬처리를 진행함 | 코루틴을 쓰면 좋았겠지만… 쓰레드풀로 함ㅋ | mongodb connection 수와 같은 pool size의 ThreadPoolTaskExecutor 를 만들고 10k 정도의 큐를 둬서 만에하나 밀려도 oom 방지 (다음에 인서트하면 그만인 작업) | . | . max response time 이 절반으로 줄었음. p50, p90 는 변화없고 p95 는 10퍼센트 정도 감소 . | mongo search 를 readPreference=secondaryPreferred로 수정 . | 부하가 많이 가고 있는 다큐먼트 갯수 5b 짜리 컬렉션에 대해 disk io 도 분산하고 mongod 부하도 분산하고자 리드할 때 세컨더리를 보도록 수정했다. 서치량은 엄청나지만 살짝 밀려도 문제가 없는 컬렉션이기에 가능했고, cache hit rate 올라오기까지 리스폰스 타임이 조금 밀리긴 했지만 무리 없이 변경할 수 있었다. (가이드) | 현재 구조상 샤드 별로 가용 secondary 가 2개인 상황인데, secondaryPreferred 를 하면 어째 한쪽 세컨더리 mongod 로만 리퀘스트가 간다. | . | redis 캐싱 시간을 늘리기 위해 redis 에 저장되는 데이터를 최소화 . | why . | redis 캐싱 시간을 유저별로 2min 으로 사용하고 있었는데, 2분 내에 변동이 적은 것이 확실하다면 캐싱시간을 늘려서 mongodb 부하 감소의 목적 | . | how . | as-is: 유저별로 A 오브젝트를 레디스 캐싱 | to-be: 유저별로 A 오브젝트의 id 를 레디스 캐싱 + 모든 A 오브젝트 리스트를 로컬캐싱하여 id 로 서치하여 A 오브젝트 획득 | . | result . | cons . | A 오브젝트의 변경이 있을 때 유저별 캐싱이 되어있어 invalidate 가 쉽지 않았기에 캐싱 시간을 늘리는데 한계가 있었으나, 캐싱시간을 늘릴수 있게됨 | . | pros . | 해시서치 과정과 로컬캐싱 메모리 추가사용 (별로 안아까움) | 레디스 캐싱타임(2min)에 콜수가 엄청 많아서, 평균 앱 사용시간(~15min)까지 캐싱타임을 늘렸으나 사실상 거의 효과가 없었음. | . | . | . | cache stampede . | why . | 한 유저가 한 번 앱을 실행하면 서버의 여러 api 를 asynchronous 하게 호출하게 되는데, 각각의 api 들이 전부 이 api 를 호출해서 캐싱이 되어있지 않은 순간에 동시에 요청이 와서 cache stampede 가 종종 발생했다. | . | how . | 정합성이 크게 문제되는 부분이 아니라 간단하게 단일 redis lock 을 잡고 ~10ms 쓰레드락 시킨 후에 다시 캐시히트를 받아내게 했다. | . | result . | 응답시간에는 거의 변화가 없었다. 스퀴징중이 아니었기에 cpu 사용률이 줄거나 혹은 쓰레드 슬립때문에 톰캣 리퀘스트 쓰레드가 늘어나는 지도 확인하지 못했다. | . | . | . GZIP . 사실 위의 어플리케이션 개선을 진행하면서, 많은 부분이 명백한 trade-off 를 가지고 있는데다가 크게 효과를 보이지 않는 개선도 많아서 불만이 많은 상태였다. 내가 만든 것은 아니지만 정말 사용성이 좋게 만들어져있는 api 였기에 호출량이 많았고, 그래서 tps 가 높아 컨테이너가 많다고 생각하고 있었기 때문이다. 어플리케이션 레벨에서는 니즈를 충족하면서 할 수 있는 모든 최적화를 해두었다고 생각했으나, 아는게 적어서 그렇게 생각했던 거였다. 요 api 는 서버 리스폰스가 100kB 정도 되는 비교적 큰 api 이다. 그래서 리턴할 때 Content-Encoding: gzip 으로 압축해서 보내고 있었고, 압축을 하고 나면 ~32kB 로 꽤 효율이 좋았다. 이거를 SRE 분께서 apm 을 분석하다가 발견해주셨는데, 요 과정이 시간이 오래 걸리더라. 사실 비정형 json 아웃풋이었기에 serialize 가 오래 걸리나? 비정형이라 kryo/proto 뭐 할 수 있는게 없겠다 생각을 하고 있었는데, gzip 압축이 문제가 될 수 있다는걸 찾아주시고 해결해주셨다. 아예 모르던 부분에서 개선이 가능하다는 걸 확인해서 또 한번 겸손이 필요한 시기임을 깨달았다. gzip 에는 compression level이 있다. BEST_SPEED~BEST_COMPRESSION 으로 압축 레벨이 올라갈수록 압축률은 높아지고 압축 속도는 떨어진다. spring boot 의 엔진으로 쓰고 있는 톰캣은 java.util.zip.GZIPOutputStream의 디폴트인 레벨 6 을 사용하는데, 이 값을 변수 등으로 설정해 줄수가 없어 org.apache.coyote.http11.filters.GZIPOutputFilter 클래스를 그대로 오버라이드 한 후에 compression level 만 BEST_SPEED 로 변경하여 적용해 보았다. @Override public int doWrite(ByteBuffer chunk) throws IOException { if (compressionStream == null) { compressionStream = new GZIPOutputStream(fakeOutputStream, true) {{ def.setLevel(Deflater.BEST_SPEED); }}; } ... } . 사실 gzip 압축 레벨을 낮추는게 무슨 큰 의미가 있겠냐 싶어서 의심이 들었는데, 결과는 아주 놀라웠다. compression 효율은 조금 떨어져서 38kB 로 약 15퍼센트 정도 손해를 봤지만, 응답속도는 p50 에서 12.5ms -&gt; 7.8ms, p95에서 26.1ms -&gt; 21.1ms 로 5 ms 정도나 떨어졌던 것이다. 아니 내가 이거 개선하려고 진짜 이것저것 다해봤는데.. 이게 gzip 압축레벨 바꿔서 해결된다고? 아.. gzip 압축레벨만 낮췄는데 극적인 효과가.. 데이터 사이즈가 클수록 효과가 큰걸까? 후.. 정말 아는 게 없다고 느낀 하루였다. 실제로 93k 정도 되는 json object 를 만들어서 gzip 압축을 해보니, 압축하는 속도만 해도 차이가 컸다. objectNode bytes size: 93154 compressed size: 25796 (DEFLATED(8)) compressed size: 93182 (NO_COMPRESSION(0)) compressed size: 29830 (BEST_SPEED(1)) compressed size: 25796 (BEST_COMPRESSION(9)) compressed size: 25849 (DEFAULT_COMPRESSION(-1)) 2.701 milliseconds &lt;&lt; DEFLATED(8) 0.101 milliseconds &lt;&lt; NO_COMPRESSION(0) 0.829 milliseconds &lt;&lt; BEST_SPEED(1) 2.665 milliseconds &lt;&lt; BEST_COMPRESSION(9) 2.122 milliseconds &lt;&lt; DEFAULT_COMPRESSION(-1) . 어쨌거나 이런식으로 남의 클래스 자체를 오버라이드 하는 방식이 마음에 들지 않아서, 다른 방안을 봤는데 서버의 server.compression.enabled 옵션을 꺼서 Content-Encoding 하지 않고, 컨테이너에 사이드카로 붙어있는 envoy 에 envoy.compression.gzip.compressor 설정을 넣어 압축을 envoy 가 수행해서 헤더를 붙여 내보내는 방식이다. 이건 따로 서버가 해주지 않아도 돼서 괜찮지만, 현재 프로젝트가 여러 환경에서 동시에 서빙되고 있는 프로젝트라 환경 디펜던시가 걸리는게 영 께름칙했다. 뭐 이리저리 다 께름칙한 방법 뿐이라.. 우선 GZIPOutputFilter클래스를 오버라이딩 해서 쓰고는 있는데, 그래! 스프링부트 자바 버전업을 하지 말자! . ",
    "url": "http://localhost:4000/develop/springboot/optimize-api",
    "relUrl": "/develop/springboot/optimize-api"
  },"1": {
    "doc": "아시아",
    "title": "아시아 초심자의 여행기",
    "content": " ",
    "url": "http://localhost:4000/travel/asia#%EC%95%84%EC%8B%9C%EC%95%84-%EC%B4%88%EC%8B%AC%EC%9E%90%EC%9D%98-%EC%97%AC%ED%96%89%EA%B8%B0",
    "relUrl": "/travel/asia#아시아-초심자의-여행기"
  },"2": {
    "doc": "아시아",
    "title": "아시아",
    "content": " ",
    "url": "http://localhost:4000/travel/asia",
    "relUrl": "/travel/asia"
  },"3": {
    "doc": "bash commands",
    "title": "bash commands",
    "content": "contents . | basic | default value | if 조건문 | xargs | awk | command | trap | pipefail | exec | shift | . 1. basic . | pipeline |, ||, &amp;, &amp;&amp; . | 는 파이프라인, 좌측 명령어의 stdout 을 우측 명령어의 argument로 전달 &amp;는 명령어를 backgroud로 실행, exit code 를 0으로 보냄 (터미널은 붙어있으니 필요시 적절하게 /dev/null 이나 기타 로그파일로 리디렉트해줘야함) || 는 or 연산자, 좌측 명령어의 exit code가 0이 아닐경우 우측 명령어 실행 &amp;&amp; 는 and 연산자, 좌측 명령어의 exit code 가 0일 경우 우측 명령어 실행 . | type . shell script 를 짜는데 유용한 built-in command 가 몇개 있다. 늘상 쓰는 pwd, export, source, exit 외에 몇 가지 binary인줄 알았는데 bash builtin 인것도 있음을 발견했다. cd, echo, history (!), alias 도 builtin 명령어들이었다. builtin 인지 아닌지 확인하는 builtin command 가 있다. :~$ type -f ${cmd} . | . 2. default value . bash 스크립트 중 parameter 인풋이 없으면 default 로 설정하는 명령어 . if [ -z \"$1\" ] then version = \"default\" else version = $1 fi . 대충 이럴텐데 (테스트는 안해봄), . version = ${@:-default} . 그냥 이렇게 쓰면 된단다. 나참…. 문법이 으이구 이걸 어떻게 알아보나이거 배쉬놈들 . 3. if 조건문 . bash 문법은 if 조건문을 사용할 때 . if [ A == B ] if [ C != D ] . 이게 아니라 . if [ A -eq B ] if [ C -ne D ] . 이렇게 써야한다. 이런 예시는 좀 빡치지만 (bash 를 잘 안쓰면 쓸 때마다 검색해야하게만든다), 훨씬 더 많은 비교 및 조사를 할 수 있게 되는 것 같다. [ -d ] : 파일이 디렉토리면 [ -e ] : 파일이 있으면 참 [ -L ] : 파일이 심볼릭 링크면 참 [ -r ] : 파일이 읽기 가능하면 참 [ -s ] : 파일의 크기가 0 보다 크면 참 [ -w ] : 파일이 쓰기 가능하면 참 [ -x ] : 파일이 실행 가능하면 참 [ 파일1 -nt 파일2 ] : 파일1이 파일2보다 최신파일이면 참 [ 파일1 -ot 파일2 ] : 파일1이 파일2보다 이전파일이면 참 [ 파일1 -ef 파일2 ] : 파일1이 파일2랑 같은 파일이면 참 // 출처: https://jink1982.tistory.com/48 [돼민이] . 등의 수많은 variation 이 가능하다. 이러면 단순히 같다를 ==로 하게 되면 통일성이 떨어지겠지 . 4. xargs . xargs 를 얼마나 잘 활용하는가 하는게 이사람이 쫌 간지나는 사람이구나를 판별하는 척도로 사용할 수 있겠다. 딱히 bash 랑만 관계있는건 아니지만, bash를 거의 사용하니까… . 사실 대부분 $(명령어) 를 이용해서도 가능하긴 하지만, -0 옵션같은 유용한 사용법이 있어 더 안전하다. ls -al $(find . -name \"*.py\") . 는 모든 py 스크립트를 찾기에 간편하지만, 파일 이름에 공백이나 다른 특수문자가 있을 경우 명령어 전체에서 에러가 난다. stdout 도 꼬이고 echo $?로 ec를 확인해봐도 1이 나온다. 이를 방지하기 위해 . find . -name \"*.py\" -print0 | xargs -0 ls -al . 이런식으로 사용하면 된다. find 의 -print0 옵션은 결과 사이를 개행문자가 아닌 널문자로 구분하도록 stdout 을 내보내는 역할을 하고, xarg의 -0옵션은 공백이 아닌 널문자로 인풋파라미터를 구분하도록 하는 옵션이다. man xargs 를 보면 알겠지만 -0 옵션 자체가 find 의 print0에 대응되도록 만들어졌다.​ . 5. awk . 아… awk…. 뭔가 웹크롤링할때처럼 text 파일들이나 df, fdisk, lshw 등 명령어의 output을 크롤링할때 많이 써서 보기만해도 기분나쁘다. 그냥… 잘 쓰면 좋은데 그냥 기분나쁘다. 잘 정리된 블로그가 있어 참조한다. 6. command . 해당 명령어는 -v 옵션과함께 사용시 arg 로 들어온 것이 bash 에서 어떤 행동을 하는지 알려준다. (alias가 되어있으면 alias도 알려줌) 이를 이용해 스크립트 내에서 사용하는 바이너리들의 존재여부를 스크립트 시작전에 파악하도록 구성할 수 있다. //내부 스크립트 진행시 sha256sum, go, javac, java 바이너리는 반드시 필요할 경우 //해당 명령어들을 사전에 command -v ${cmd} 을 통해 진행, exitcode가 0이 아닐경우 //stderr로 에러메세지 뿜고 스크립트 종료 for cmd in sha256sum go javac java; do if ! command -v $cmd &amp;&gt; /dev/null; then echo &gt;&amp;2 \"error: $cmd not found\" exit 1 fi done . 7. trap . trap 명령어는 go 언어의 defer같은 느낌으로다가 사용할수 있는 builtin command이다. 특정 시그널을 받을 때 실행할 명령어를 지정할 수 있다. // 스크립트가 종료될 때 다음 명령어를 수행하도록 trap \"echo \\\"ALL IS WELL\\\"\" EXIT // ERR SIG를 받을 때 다음 명령어를 수행한다. trap \"echo \\\"SOMETHING\\'S WRONG\\\"\" ERR . 8. pipefail . 스크립트 내부에서 명령어가 실패할경우 bash는 스크립트를 끝내지않고 다음 명령어를 수행한다. set -eouE pipefail . -e 옵션은 exit code가 0 이 아닌 커맨드를 만났을 때 script를 진행하지 않고 끝내라는 셋팅이다. ($cmd || true 등의 명령어를 통해 실패해도 script 종료가 나지 않게 지정할 수 있다.) 다만 이 경우 pipeline 을 통한 명령어가 실행될 때는 pipeline 의 좌측 명령어가 exit code 를 0이 아니게 내뿜어도 우측 명령어가 0이면 에러가 아니게 된다. 즉, . ls /not/existing/dir | grep something . 같은 명령어의 경우 좌측이 exit code 2로 나와도 파이프라인을 받는 명령어가 exit code를 0을 내밀기에 해당 스크립트는 여전히 진행된다. 이를 막기위해서 -o pipefail 옵션도 주면 된다. -E 옵션을 주지 않으면 위의 trap이 지정한 ERR SIG를 캐치하지 못한다. -u 옵션은 setting 되지 않은 환경변수를 호출했을 때 empty를 return하지 않고 script를 종료시킨다. setting 되지 않은 환경변수 하니까 나온건데 지난번 ${@:-default} 는 ${a:-b} 문법의 확장판이다. a라는 변수가 있으면 a로 세팅하고 없으면 b로 하라는 말이다. -u 옵션은 이 문법에서 a가 세팅되어있지않더라도 에러를뿜거나 하지는 않는다. 추가로, 디버깅을 위해 명령어가 실행되기 전 명령어를 인쇄하도록 하고싶으면 -x 옵션을 사용하면 된다. ​ . 9. exec . 명령어를 실행하되 실행한 bash 의 하위 프로세스로 돌리는게 아니고 실행한 프로세스의 pid를 물려받아 실행하도록 한다. 허접은 잘 쓸수가 없다. 10. shift . $1, $2 … 등으로 사용하는 input args 를 왼쪽으로 한칸씩 이동할 때 쓴다. 왜있는건지 도통 모르겠다. 고수들은 잘쓰려나? 약간 java iterable 같은거에서 cursor 옮기는 느낌이려나 . ",
    "url": "http://localhost:4000/develop/etc/bash",
    "relUrl": "/develop/etc/bash"
  },"4": {
    "doc": "고양이",
    "title": "고양이 이야기",
    "content": "달리와 자몽이 . ",
    "url": "http://localhost:4000/cats#%EA%B3%A0%EC%96%91%EC%9D%B4-%EC%9D%B4%EC%95%BC%EA%B8%B0",
    "relUrl": "/cats#고양이-이야기"
  },"5": {
    "doc": "고양이",
    "title": "고양이",
    "content": " ",
    "url": "http://localhost:4000/cats",
    "relUrl": "/cats"
  },"6": {
    "doc": "2019-08 중국 칭다오",
    "title": "여행의 시작",
    "content": ". | 월화수목금 휴가를 쓰는 것은 뭔가 좀 그렇다 | . 일견 납득하기 어려운 이유로 나의 휴가 결재를 반려시키고는 자기는 그냥 이직을 해버린 전 실장님의 유지를 받들어, 일주일의 몽골 여행을 취소하고 단기간의 칭다오 여행을 다녀오게 됐다. 뭐 언젠가는 중국 여행 한 번쯤 다녀와야지 생각을 했지만 이렇게 갑자기 가게 될 줄은 몰랐다. 그냥 여행인데 뭐 별다를 게 있으려나? . 여타 다른 나라들과 별 다를 바 없다고 생각하고 안일 그 자체로 여행을 준비하려다 비자에 당해버린 게 나뿐만은 아닐 것이다. 무비자 여행 가능국 세계 3위에 빛나는 대한민국 여권이 고작 만리밖에 되지 않는 장성에 가로막혀 있다는 사실은 이미 달콤한 중국몽을 꾸고 있는 이들에게는 그다지 고통스러운 일이 아닐지도 모른다. 중국 대사관에서는 여권사진과는 별도의 6개월 이내의 사진, 우리 아빠의 전화번호, 내 직장 주소와 전화번호를 포함한 대부분의 개인정보를 수집해갔고, 3박 4일의 중국 입장료로 8만 원(사진, 대행료 포함) 가량의 부대비용을 청구했다. 재훈이가 이란에 다녀왔다는 사실 때문에 ESTA가 발급되지 않아 200불에 육박하는 미국 입장료를 내야 한다는 사실은 내 분노한 마음을 이내 가라앉혀 주었다. 비행기 타고싶다.. 보통 국제선 내부는 목적지의 영토로 간주한다고 하니, 중국 여행은 중국 동방항공 비행기에 탑승하는 것부터 시작되었다. 중국에 대한 첫인상은 대단했다. 그들은 무섭게 생겼으며 무서운 냄새가 나고 무서운 눈초리를 보내며 자고 있었다. 무서운 냄새에 대해 함부로 인상을 찌푸렸다가는 1합만에 목이 달아날지도 몰라 조용히 다리를 모으고 공손하게 잠을 청했지만 옆에서 장비같이 생긴 빡빡머리 중국인이 자꾸 가래를 끓이며 내 단잠을 방해했으므로 취침은 이내 그만두었다. 중국 입국과정은 다른 국가들의 그것과 별 다를 바가 없었지만 공안의 만행에 대한 뉴스 기사들과 중국의 거대한 공권력에 대한 상상력은 그 과정을 평소보다 더 무섭게 만들었다. 그들은 내 열 손가락의 지문을 전부 찍어갔으며 아무 질문도 하지 않은 채 이리저리 나를 끌고 다녔다. 손가락만 까딱이며 나를 이리저리 조종했던 그 과정은 흡사 대학교 신입생에게 굴종의 의미로 장기자랑을 시키는 것처럼 중국 초심자에게 시진핑과 공산당 공권력의 무서움을 몸소 보여주는 것이었을지도 모른다. 칭다오의 날씨는 아주 청명했다. 기온도 서울보다 3~4도 낮았으며 습도도 거의 없고 공기도 청명하여 아주 마음에 들었다. 이 몹쓸 놈들이 오만 미세먼지는 한국에 오지게 보내고 정작 자신들은 청명한 하늘을 갖고 있다는 것에 매우 불쾌한 기분이 들었다. 시내로 들어가는 공항버스 안에서 찍은 사진 . ",
    "url": "http://localhost:4000/travel/asia/china_1#%EC%97%AC%ED%96%89%EC%9D%98-%EC%8B%9C%EC%9E%91",
    "relUrl": "/travel/asia/china_1#여행의-시작"
  },"7": {
    "doc": "2019-08 중국 칭다오",
    "title": "칭다오의 음식",
    "content": "칭다오는 맥주로 유명하다. 19세기 말 20세기 초에 독일이 칭다오 지역을 청나라로부터 조차하여 사용할 때 친히 독일의 맥주 제조 기술을 전수하고 공장을 지어주었기에 칭다오 맥주의 맛은 세계적으로도 꽤 좋다고 한다. 조차는커녕 늑약으로 대한제국 땅을 정복하고 내선일체로 편입해버렸음에도 불구하고 그럴듯한 주류제조기술 하나 전수해주지 않은 모 제국주의 국가에 비하면 비교적 혜자였다고 할 수 있겠다. 우리는 여행 중에 물보다 맥주를 더 많이 마셨기에 거의 항상 취한 상태로 돌아다녔다고 해도 무방하다. 우리가 다녔던 곳에서는 맥주박물관과 오사공원을 제외하면 한국인을 코빼기도 찾아볼 수 없었으므로 취한 상태에서 문명인들이라면 응당 하지 않고 해서도 안 될 개소리들을 양껏 하고 다닐 수 있어 여행에 즐거움을 한 층 더하였다. 칭다오에서만 판매한다는 원장 맥주는 1리터에 약 38~45 위안의 시세를 형성하여 일반 칭다오 맥주의 2~3배 가격이었지만 그 맛이 매우 탁월하여 선택하지 않을 수 없었다. 계속 마시고 또 마셨던 기억이 어렴풋이 난다. 칭다오 맥주박물관에서 한 잔, 맛 구별은 못해도 뭐가 맛있는 건지는 안다. 칭다오의 음식은 대체적으로 해산물이 주류를 이루고 있다. 현지인만 가득한 식당에서 재훈이의 한자 실력을 바탕으로 다양한 음식을 먹어볼 수 있었는데, 바지락, 가리비, 새우, 생선조림, 미니 가재(샤오롱샤), 양 및 소의 꼬치구이뿐 아니라 오리 대가리(사진을 올리고 싶지만 비주얼이 그다지 좋지 않아 그만두도록 해야겠다), 양의 척수, 심지어는 불가사리도 먹었다. 오리 대가리는 먹을 게 없을뿐더러 나의 약한 비위와 적나라한 비주얼 때문에 끝까지 먹지는 못했다. 양의 척수 또한 뭔가 불쾌한 식감이 느껴져 만족스럽지 못하게 먹었고, 불가사리는 게의 내장 맛이 났고 다리 두 개를 먹긴 했지만 다음에 또 먹고 싶지는 않았다. 불가사리의 껍데기는 먹어본 재훈이의 말을 빌면 아이스크림 콘의 맛이 나지만 씹어도 계속 바삭한 뭔가의 불쾌함이 있다고 한다. 불가사리의 갈색 속살, 게장 맛이 나지만 또 먹고 싶지는 않다. 샤오롱샤, 생각보다 맛이 좋다. 대부분의 음식이 아주 훌륭했지만 뭐니 뭐니 해도 일등 술안주는 라 깔라 라고 하는 바지락 요리였다. 아니 방금 라 깔라가 독음이 맞는지 검색해봤는데 백종원 3대 천왕에 나온 요리라고 하네. 어쩐지 맛있더라… 젠장! 더 먹고 올걸! 이 요리의 가장 큰 장점은 한 접시에 10위안이라는 점이다. 약 1700원 돈에 아래와 같은 바지락을 듬뿍 먹을 수 있다. 혜자 누나도 여기 와서 자신의 부족함에 눈물을 흘리고 갔다는 후문. 바지락의 씨알이 너무 작아 이 정도면 지속 가능한 발전을 포기하고 후대를 착취하는 남획에 가깝다고 생각했다. 아니 우리 서해를 침범해서 깡그리 씨알을 말려놓는 게 중국 어선 놈들이라더니, 진짜 이 정도 씨알도 다 쓸어가 버리나 싶었다. 나쁜 놈들… 맛있게 최선을 다해 먹어서 혼내주기로 했다. 아, 사진을 보니 또 먹고 싶군. 라 깔라. 아 개꿀맛! 인정이야! . 예전에 연수 차 미국에 방문했을 때 북경오리 요리를 먹었던 것 같은데, 그 사진도 없고 먹었던 기억이나 맛도 생각나질 않는다. 아무래도 별 특징이 없었거나, 같이 주문했던 랍스터를 깨 먹는데 신경을 너무 많이 썼거나 해서 그런 것 같다. 그래서 이번에도 먹으러 갈 때 별 기대를 하지 않았으나, 그 맛은 굉장했다. 전취덕이라고 중국에서 유명한 북경오리 체인점인 것 같았다. 우리가 먹었던 음식점 중 유일하게 뭔가 잘 차려진 식당 같은 곳이었고 한국인도 많았으나, 역시 영어가 되는 직원은 찾아볼 수 없었다. 건방진 중국 놈들… 세계정세를 거스르려 하다니, 아! 또 먹고 싶다… . 북경식 오리구이, 베이징 카오야. 타이동 야시장에도 방문했었는데, 1 앉아서 먹을 곳이 없다; 2 메뉴가 별로 입맛을 돋우지 못하였다; 3 역한 취두부 냄새를 막을 수단이 없다 등의 이유로 아무것도 취식하지 않았다. 방콕의 야시장은 정말 대단했었지… 이 외에도 다양한 음식들과 음료들을 맛보았는데, 만두와 면 요리도 굉장히 맛이 좋았고 웬만하면 실패하지 않았다. 아무래도 중국이 어서 비자를 해제하고 영어 및 한국어가 가능한 직원들을 대폭 고용하여 일본을 대체할 수 있는 식도락 여행지로 칭다오를 무럭무럭 성장시켜주었으면 좋겠다. 비자 8만 원의 장벽은 대단히 높다. 아, 저 맛있는 것들을 또 먹을 날이 왔으면 좋겠다. 아!!!!! 이래서 내가 살이 안 빠지는구나! . ",
    "url": "http://localhost:4000/travel/asia/china_1#%EC%B9%AD%EB%8B%A4%EC%98%A4%EC%9D%98-%EC%9D%8C%EC%8B%9D",
    "relUrl": "/travel/asia/china_1#칭다오의-음식"
  },"8": {
    "doc": "2019-08 중국 칭다오",
    "title": "관광에 관하여",
    "content": "중국의 구글 . 나는 일반적으로 현지인들만 있는 여행지를 선호하는 평범한 여행자임에도 불구하고 오만하기 짝이 없게 현지어를 잘 배워가지 않는다. 이는 내 언어능력이 모자라다는 것도 그 이유가 되겠지만, 가장 큰 이유는 어차피 구글이 다 해주기 때문이다. 구글 지도만 있으면 어디든 갈 수 있고, 구글 번역기만 있으면 무슨 메뉴든 주문할 수 있기 때문이다. 트립 어드바이저와 에어비앤비, 우버 등의 인프라는 항상 나를 불필요한 삐끼와의 싸움 외 자잘한 곤란들에 빠지지 않도록 도와준다. 중국은 그게 다 막혀있다. 구글 맵에는 지하철도 버스도 건물들도 표시되어 있지 않으며 타임라인에는 내가 수면 보행으로 잔교 근처 바다를 배회한 것으로 표시됐다. 대신 중국 app 생태계에는 각각의 역할을 대신해 줄 중국만의 app 이 다 따로 있다. 바이두, DD, 투찌아 등이 그것인데, 모든 것을 대신해 줄 바이두는 중국어 외의 다른 언어를 지원조차 해주지 않으며 바이두 지도를 들어가려고 하면 자꾸 내 핸드폰에 apk 파일 설치 시도를 해서 두려움에 설치를 포기했다. (아마 추측컨대 중국 핸드폰을 사용하면 해당 apk를 내 허가 없이 자동으로 설치할 것 같다.) 인구가 14억 쯤 하는 나라는 스스로 모든 인프라를 만들어 사용해도 차고 넘치는 고객 수와 넘치는 인재들의 개발 실력, 유지보수 능력 등의 뒷받침에 힘입어 그 생태계를 유지할 수 있으니 그 자체로 어느 정도 부럽다고 할 수 있다. 이것이 습근평의 중국몽인가? 함께 하자 중국몽! . 중국의 도로 . 호탕한 일부 중국인들은 왕복 5~6차선쯤 되는 도로라도 손을 들어 차를 멈추며 당당하게 걸어간다. 그 덕분인지는 몰라도 대체적인 도로 문화가 차나 사람이나 오토바이나 먼저 들이미는 사람이 이기는 구조로 되어있고, 분노한 패배자들의 클락션 소리가 도로를 지배하고 있다. 나 정도 되는 운전실력으로는 살아남을 수 없겠다는 생각이 들어 한국의 도로에 감사함을 느끼게 되었다. 그래도 90퍼센트가 넘는 오토바이가 EV 모델이어서 시끄러운 오토바이 내연기관 엔진 소리는 들리지 않아 좋았다. 어떻게 이렇게 다 전기오토바이로 바꿔버릴 수 있었을까? 하여튼 공산당 놈들은 한다면 무지막지하게 그냥 추진해버리는 반쯤은 좋고 반쯤은 나쁜 습성을 지니고 있는 것 같다. 중국의 도로에는 정말 다양한 브랜드의 자동차들이 굴러다니고 있다. 도요타, 혼다, 미쯔비시, 마쯔다, 스즈키, 렉서스, 어큐라, 닛싼, 현대, 기아, 쉐보레, 뷰익(정말 많음), 포드, 벤츠, BMW, 아우디, 캐딜락, 지프, 폭스바겐, 포르셰, 벤틀리, 미니 정도가 기억에 남아있고, 처음 보는 중국차 브랜드들 - BAIC, BYD, FAW, FOTON, HAIMA, JAC 등이 다양하게 도로를 지배하고 있었다. 사실 외제차 브랜드들은 진짜 그 외제차인지 아니면 로고를 따라한 중국의 짭 자동차 인지 확인을 못한 차도 많다. 특히 벤틀리… 지금 찾아봤는데 Riich라는 중국차가 아주 가관이구만. 전설의 더블 현대 마크를 단 차도 하나 봤다. 사진을 찍어놓지 못한 게 아쉬울 뿐..!! 우리나라에도 더 많은 브랜드의 자동차들이 들어와서 도로를 아름답게 만들어주고 내 선택지를 늘려줬으면 좋겠다. 중국의 인민 . 중국은 사람이 많다. 어딜 가도 많다는 말이 정말이다. 진짜 많았다. 메인 스트리트에서 ‘아 사람 많다, 좀 가생이로 가야지’ 하고 계속 가생이로 가도 계속 사람이 많다. 아, 사람 많아. 칭다오 외의 지역에서 주말이라고 많이들 칭다오로 놀러 온 것 같았다. 여행객 차림새를 하고 길을 물어보고 다니는 사람들도 다 중국인이었다. 아, 중국인 진짜 많네. 중국 공공장소에는 문명(文明) 이란 단어가 유독 강조되어 있다. 뭐 해서 문명인 되자, 뭐 하지 말고 문명인 되자, 앞으로의 작은 한걸음은 문명으로의 큰 한걸음, 아! 그럼에도 중국 인민들에게 아직 문명은 요원한 모양이다. 말로만 들어봤던 시간과 장소를 가리지 않는 중국 중년 남성들의 베이징식 비키니는 눈을, 길거리에서 삶아서 파는 불가사리에서 풍기는 어딘가 역한 냄새는 코를, 바로 옆에서 대화하면서도 소리를 질러대는 중국인들의 목소리는 귀를 괴롭혔다. 그중에서도 나의 관심을 한큐에 잡아당긴 건 화장실 문 앞에서 길바닥에 오줌을 싸는 아이였다. 그냥 화장실 앞 길바닥에 갑자기 오줌을 싸는데 그 누구도 말리지 않고 신경조차 쓰지 않는 모습에 나는 적잖이 당황하여 얼른 사진을 찍어버렸다. 아니 중국 당이 그렇게 문명 문명 노래를 부르는데 중국 인민들이 조금이나마 신경이라도 썼으면 좋겠다. 왜 여기다 싸는 건데... 중국의 공권력 . 오사광장 쪽에 가면 시 청사 건물 앞 광장에 무서운 붉은색의 표어가 걸려있다. 그 앞에 서면 나도 모르게 공손하게 손을 앞으로 모으게 된다. 자칫 해당 선전에 모욕적인 언사를 하거나 천안문, 법륜공 등을 입에 담다가 공안에게 걸리게 되면 위치 불명의 어딘가로 가서 취조를 당할지 모른다는 두려움에 나도 모르게 내면의 겸손함이 밖으로 나오게 되는 것 같다. 우리네 광장이었다면 으레 반정부 시위와 반 반정부 시위가 동시에 벌어지고 있었겠지만, 중국에서 집회 및 결사의 자유를 지녔던 자들은 30년 전 천안문 앞에서 모두 홀연히 종적을 감추었으므로 이 광장에는 체제 선전용 표어만 광장에 덩그러니 남겨져 있다. 시진핑 신시대 중국 특색 사회주의 사상의 위대한 기치를 높이 들자, 중화민족 위대한 부흥의 중국몽을 실현하기 위해 쉬지 말고 분투하자. 칭다오의 유명한 야경은 해가 거의 질 무렵 해안가의 모든 큰 빌딩에 LED 등이 동시에 들어오면서 시작된다. 그러나, 아름다운 불빛 쇼가 펼쳐지기 전 약 10여분 동안은 중국 체제에 대한 선전이 먼저 스카이라인을 장악한다. 대충 군대에 대한 이야기, 군대와 국민이 서로 화합하고 국력을 키워야 한다는 이야기, 문명으로 가자는 이야기 등이 빨갛게 도시를 메우는데, 자유진영의 인사라면 제법 두려움을 느낄 만하겠지만 중국몽을 꾸는 이들이라면 그에 반할지도 모르겠다. 마치 초등학생 시절 학교 대항 축구경기를 보러 갔을 때 다른 학교에서 하는 카드섹션을 보고 ‘이야, 저 학교는 대단한 단결력을 가진 경쟁력 있는 학교구나!’ 하고 생각하는 것과 비슷한 것 같았다. 초심을 잃지 말고 우리 사명을 기억하자 . 이런 정부 차원에서의 강요에 의한 단결력이 열심히 따라가야 하는 후발주자로써 굉장한 이득을 줄 수는 있겠지만, 그를 따르기 위해 얼마나 많은 희생이 강요되었을지 생각해보면 두려울 뿐이다. 기타 . | 중국 남성들의 헤어스타일은 아주 한결같았다. 아주 빡빡이이거나 매우 짧은 스포츠 컷. 그 때문인지 중국인들의 인상은 아주 무서운 편에 속했다. 다행히 요즘 내 몸이 지방으로 벌크업 되어있어 어딜 가서 꿀리지 않는 무게가 되었기에 당당하게 어깨를 펴고 한국어를 하면서 다닐 수 있었다. | 아직 90년대 한국처럼 아무 장소에서나 담배를 피워댔다. 아이가 있건 없건, 심지어 잠시 구경하러 들어간 중국형 하이마트 같은 전자제품 판매점 내부에서도 담배를 피우더라. DD에서 불러 탄 자동차에서도 담배 쩐내가 가득했다. | 중국형 농협 하나로마트에 들어가 보니 마케팅적인 측면에서 여러 가지를 가르쳐 주어야만 할 것 같았다. 예를 들면 빵집 옆에는 새우젓을 산더미처럼 쌓아놓으면 안 된다던가, 만두집 옆에는 두리안을 진열해놓으면 안 된다던가 하는 것들 말이다. | 중국 지하철은 입장 시에 공항 게이트 통과하듯이 짐 검사와 신체검사를 수행한다. 밤에 도로에 지나는 차 하나하나마다 전부 플래시를 터트려가며 사진을 찍어놓는다. 이제는 나도 중국에 개인정보를 팔았으니 자동 얼굴인식기가 나도 인식할 것이다. 한국인인 게 다행이다. | 밤이 되면 길거리에서 부적을 쌓아놓고 불을 지르는데, 화재에 대한 경각심이 부족한 것이 아닌가 생각이 들었다. 다른 문화에 대해 왈가왈부할 생각은 없지만 적어도 안전은 지켰으면 좋겠다. | . ",
    "url": "http://localhost:4000/travel/asia/china_1#%EA%B4%80%EA%B4%91%EC%97%90-%EA%B4%80%ED%95%98%EC%97%AC",
    "relUrl": "/travel/asia/china_1#관광에-관하여"
  },"9": {
    "doc": "2019-08 중국 칭다오",
    "title": "칭다오의 숙소",
    "content": "나는 칭다오에서 묵은 숙박시설에 대해 사람들에게 말하는 것을 굉장히 고대하고 있었다. 이제 그 글을 쓸 수 있게 되었으나, 혹여나 별 것 아닌 것처럼 쓰게 될까 두렵다. 중국 방문 시 방문 비자에는 반드시 호텔에서 숙박한다고 기입해야 하지만, 우리는 에어비앤비를 이용하였다. 이게 실수였을까? 호스트(인지 중개인인지)가 보내준 지도 사진의 화살표대로 따라 들어갔던 골목에서 우리는 이내 밖으로 나와 그 블록을 한 바퀴 돌았다. 여기는 공사장인데? 지도가 잘못됐나? 나 홀로 집에 2 영화에서 케빈이 뉴욕의 공사 중인 집에 들어갔을 때가 떠올랐다. 골목에는 족히 일 년은 열린 적 없어 보이는 나무문들과 시멘트, 아교, 철근, 환풍기 등의 공사자재들과 옆 건물의 옅은 빛이 있었다. 그 골목의 끝에 공사 중인 건물 내부로 들어가는 문이 있었고, 놀랍게도 그 문이 우리 숙소로 들어가는 문이었다. 우리는 이 문을 찾는데만 한참이 걸렸다. 내 생각에 중국의 건물은 우선 철근콘크리트만 다 올려놓고 분양이 되고 나서야 내부 공사 착공에 들어가는 것 같았다. 아니면 분양사기를 당한 인민 한 명이 외국인들을 골려주기 위해 에어비앤비로 등록을 한 것일 수도 있겠다. 우리 방을 제외한 옆방들은 분양이 되지 않았는지 창문은커녕 복도 전기설비조차 되어있지 않은 콘크리트 그 자체였다. 숙소 내부로 들어가니 뭔가 있긴 했는데, 사진과는 다르게(사진 기술에 감탄할 뿐) 두세 평 되는 숙소 내부에서는 공사 시멘트 냄새, 지독한 곰팡이 냄새가 가득했다. 급격한 산업화를 따라가기 위해 상경한 농민공의 삶을 체험해볼 수 있는 좋은 기회라고 생각하기로 했지만 그래도 아주 불쾌한 것은 어쩔 수 없었다. 이란과 파키스탄에서 더 열악한 주거환경을 가졌었다고 증언한 재훈이도 중국몽 숙소 퀄리티에 혀를 내둘렀다. 건물 복도. 창문으로 다른 방 내부를 보면 그냥 콘크리트 덩어리만 보인다. 숙소 침대 뷰. 전망이 좋다. 하루 종일 여행하고 숙소로 들어가는 것 자체가 기대가 되기는커녕 두려움이 앞을 가렸으므로, 결국 우리는 마지막 날 하루 숙박비 중복 지출을 감수하고 공항 근처 호텔로 다시 잡았다. 그 숙소 또한 원래대로라면 전혀 만족스럽지 않은, 사람 한 둘쯤 죽었다 해도 이상하지 않을 퀄리티를 자랑하긴 했지만 그래도 이전 숙소를 떠올리며 꿀잠을 잘 수는 있었다. 오래된 카펫과 담배냄새, Eagles의 Hotel California 노래가 흘러나올 것만 같은 분위기에서 이전 숙소에 대해 에어비앤비에 남길 악플을 생각하며 우리는 웃음을 지었다. 이주한 호텔 객실의 급수장치 . 한국에 돌아와 찾아보니 중국에서는 분양할 때 인테리어나 내부 수도공사 등의 인프라 작업을 하나도 하지 않은 채 분양을 한다고 한다. 전부 다 입주자가 해야 한다고 하니, 우리가 잤던 그 건물은 그냥 중국의 평범한 건물이었던 것이다. 아니, 어쩐지 완다광장에 갔을 때도 바로 옆 부스에 입점이 되지 않아 가림막도 없이 그냥 콘크리트 포대, 아교 통 등이 놓여 있어도 핸드폰이나 옷을 버젓이 팔고 있더라니. 약간 베트남과 한국 중간 정도의 발전 상황을 가지고 있는 사회 같다고 생각했다. Summary . 비자 때문에 적지 않은 돈의 통행료를 추가로 내야 한다는 점과 개인정보를 모두 중국에 넘겨야 한다는 점을 제외하면 중국은 아주 매력적인 선택지인 것 같다. 중화민국의 본토를 강제로 점거하고 있는 현 습 모 국가수반과 그를 위시한 공산당 정부의 만행은 전혀 탐탁지 않지만 여행지로써의 중국은 많은 것을 충족시켜주는 탁월한 여행지라고 할 수 있겠다. 다음에 기회가 된다면 복수비자를 발급받아 쉬는 형태로 여러 번 다녀올 수 있었으면 좋겠다. ",
    "url": "http://localhost:4000/travel/asia/china_1#%EC%B9%AD%EB%8B%A4%EC%98%A4%EC%9D%98-%EC%88%99%EC%86%8C",
    "relUrl": "/travel/asia/china_1#칭다오의-숙소"
  },"10": {
    "doc": "2019-08 중국 칭다오",
    "title": "2019-08 중국 칭다오",
    "content": " ",
    "url": "http://localhost:4000/travel/asia/china_1",
    "relUrl": "/travel/asia/china_1"
  },"11": {
    "doc": "Java collectors",
    "title": "Java collectors",
    "content": "Collector 는, 아무래도, Collection Framework 의 꽃이 아닐까? 이름부터 그렇잖아. Collector! . stream 의 끝에는 거의 forEach 나 collect 가 기다리고 있다. 여러 필터, 정렬, 매핑 등등으로부터 살아남은 스트림의 엘레먼트들은 forEach 를 만나 소멸하거나 collector 를 만나 새로운 Return Type으로 반환이 되게 된다. forEach는 argument 로 Consumer&lt;? super ElementType&gt; 를 받으므로 그냥 함수 꼴을 하고 있는 pseudo-일급객체 하나를 넣어주면 되지만, collect는 argument가 Collector&lt;? super ElementType, A, R&gt; 을 받는데, 아니 도대체가 javadoc만읽어서는 잘 이해가 되지 않았던 것이다. functional interface 도 아니고, 어차피 java.util.stream.Collectors 에 유용한건 이미 다있으니 그냥 갖다가 쓰면 되니까 썼는데, 그래도 하나쯤 custom collector 가 있어야하지 않을까? 하는 노파심에, 그래! 해보자 하고 알아보게 되었다. Collector&lt;T, A, R&gt; 클래스는 Target, Accumulator, Return의 generic 타입을 가지는 인터페이스이고, 이를 구현한 클래스가 supplier, accumulator, combiner, finisher와 characteristics 를 오버라이드하여 stream 의 collect 메서드에서 사용할 수 있게 된다. 이를 이용해 java.util.stream.Collectors 의 joining(String delimeter) 메서드를 직접 구현해보면, . public class CustomCollector&lt;T&gt; extends Collector&lt;T, StringBuilder, String&gt; { private String delimeter_; private CustomCollector(String del) { delimeter_ = del; } public static &lt;T&gt; CustomCollector&lt;T&gt; joining(String del) { return new CustomCollector&lt;&gt;(del); } @Override public Supplier&lt;StringBuilder&gt; supplier() { return StringBuilder::new; } @Override public BiConsumer&lt;StringBuilder, T&gt; accumulator() { return (sb, value) -&gt; sb.append(value).append(delimeter_); } @Override public BinaryOperator&lt;StringBuilder&gt; combiner() { return (sb1, sb2) -&gt; sb1.append(sb2); } @Override public Function&lt;StringBuilder, String&gt; finisher() { return sb -&gt; sb.subSequence(0, sb.length() - delimeter_.length()).toString(); } @Override public Set&lt;Characteristics&gt; characteristics() { return ImmutableSet.of(Characteristics.UNORDERED); } } . 정도가 되겠다. Accumulator 로 StringBuilder 를 사용했고, combiner(2016년 스택오버플로에 의하면 parallel stream으로 병렬적으로 여러 작업이 이루어지고 이 작업들을 합칠 때만 사용됨)및 finisher, delimeter 를 삽입하는 방법은 최적화를 하지 않고 생각나는대로 짜서 효율은 모르겠지만, 어쨌든 이렇게 해 놓으면 java.util.stream.Collectors.joining 과 동일하게 사용할 수 있다. 물론 실제로는 java.util.StringJoiner 를 accumulator로 사용하는 것 같다. void main() { List&lt;String&gt; list = Arrays.asList(\"dalee\",\"jumping\",\"higher\"); String value = list.stream().collect(CustomCollector.joining(\"::\")); System.out.println(value); // dalee::jumping::higher } . Collector.of 메서드를 이용하면 이것 역시 함수형태(함수형 프로그래밍을 위해 함수 형태를 일급객체로 사용하기위한 Java의 몸부림이라고 볼수있겠다.) argument를 이용해 사용할 수 있다. String delimeter = \"::\"; Collector&lt;String, ?, String&gt; c = Collector.of( StringBuilder::new, // supplier (sb, t) -&gt; sb.append(t).append(delimeter), // accumulator StringBuilder::append, // combiner sb -&gt; sb.subSequence(0, sb.length() - delimeter.length()).toString(), // finisher Characteristics.UNORDERED // characteristics ); . 더하여, double colon 으로 이뤄지는 method reference 에 관하여, 함수 형태의 람다식의 사용을 간편하게 해주는 것으로, 크게 4가지의 사용법이 있다. (args) -&gt; Class.staticMethod(args) === Class::staticMethod (obj, args) -&gt; obj.instanceMethod(args) === ObjectType::instanceMethod (args) -&gt; obj.instanceMethod(args) === obj::instanceMethod (args) -&gt; new ClassName(args) === ClassName::new . 즉, 다음과 같이 줄일 수 있다. Supplier&lt;StringBuilder&gt; s = () -&gt; new StringBuilder(); Supplier&lt;StringBuilder&gt; s = StringBuilder::new; // 동치 Function&lt;String, StringBuilder&gt; f = (input) -&gt; new StringBuilder(input); Function&lt;String, StringBuilder&gt; f = StringBuilder::new; BiFunction&lt;String, String, StringBuilder&gt; f = StringBuilder::new; // Error (StringBuilder 의 생성자는 param 을 1개만 받음) // 동치 BiFunction&lt;String, String, String&gt; bf = (input1, input2) -&gt; input1 + input2; BiFunction&lt;String, String, String&gt; bf = String::concat; // 동치 Integer temp = 4; Comparable&lt;Integer&gt; cc = input -&gt; temp.compareTo(input); Comparable&lt;Integer&gt; cc = temp::compareTo; // 동치미 . ",
    "url": "http://localhost:4000/develop/java/collector",
    "relUrl": "/develop/java/collector"
  },"12": {
    "doc": "conditional on bean",
    "title": "conditional on bean",
    "content": "@ConditionalOnBean 의 설명은 다음과 같다. | that only matches when beans meeting all the specified requirements are already contained in the BeanFactory. | . 대충 인자로 들어있는 클래스의 빈이 빈팩토리에 존재한다면 컴포넌트를 생성한다는 말이다. @ConditionalOnMissingBean 은 반대로 빈팩토리에 없을 때 컴포넌트를 생성한다는 것이다. 즉, . @Configuration class ApplicationConfiguration{ @Bean @ConditionalOnBean(TestProperty::class) fun someConfig(testProperty: TestProperty): SomeConfig { return SomeConfig(testProperty) } } . 이 코드에서 TestProperty 타입의 빈이 있을 경우에 해당 빈을 주입받아 SomeConfig 빈을 만들고, TestProperty 빈이 없으면 SomeConfig 빈을 만들지 않도록 한다. 허나, 다음과 같은 경우일 지라도 SomeConfig 빈이 생성될 수가 있다. @Configuration class ApplicationConfiguration: ApplicationContextAware { private lateinit var applicationContext: ApplicationContext private val logger = Logger.getLogger(ApplicationConfiguration::class.simpleName) override fun setApplicationContext(applicationContext: ApplicationContext) { this.applicationContext = applicationContext } @Bean @ConditionalOnMissingBean(TestProperty::class) fun someConfig(testProperty: TestProperty): SomeConfig { logger.info(\"testProperty has been injected! $testProperty\") logger.info(\"testProperty found in application context! ${applicationContext.getBean(\"testProperty\")}\") return SomeConfig(testProperty) } } // output // testProperty has been injected! com.whojes.common.config.TestPropertyImpl@4aa3d36 // testProperty found in application context! com.whojes.common.config.TestPropertyImpl@4aa3d36 . @ConditionalOnMissingBean 을 달아놨는데도 주입도 되고 applicationContext 에서 가져올 수도 있다. 엥? . | already contained in the BeanFactory | . 이 문장의 의미는 @ConditionalOn(Missing)Bean 의 인자로 사용된 빈의 컴포넌트 스캔 순서가 해당 클래스의 컴포넌트 스캔 순서보다 빨라야만 한다는 것이다. 즉 Bean 이 최종적으로 create 되어있는 상태를 보는 게 아니라, 저 애너테이션이 달려있는 부분을 스캔할 때에 빈팩토리에 해당 bean definition 이 등록되어 있어야 한다. (Bean creation 이 아니므로 @Order, @DependsOn 류의 생성 순서보장은 먹히지 않는다.) . 다음과 같은 상황을 생각해보자. // com.whojes.demo.configuration.ApplicationConfiguration @Configuration class ApplicationConfiguration { @Bean @ConditionalOnBean(TestProperty::class) fun someConfig(testProperty: TestProperty): SomeConfig { return SomeConfig(testProperty) } } . 이 클래스는 SomeConfig 빈을 생성하는데, TestProperty 빈이 있어야만 생성을 한다. 내가 TestProperty 를 생성을 해줘야 하는데, . @Configuration class Ao { @Bean fun testProperty(): TestProperty = TestProperty() } . @Configuration class Aq { @Bean fun testProperty(): TestProperty = TestProperty() } . Ao 클래스로 생성을 하던 Aq 클래스로 생성을 하던 런타임에 TestProperty 빈을 인젝션받거나 applicationContext 에서 찾는건 문제없이 가능하지만, 컴포넌트 스캔 순서가 Ao -&gt; ApplicationConfiguration -&gt; Aq 이기 때문에 Aq 로 빈을 만들면 ApplicationConfiguration 에 있는 @ConditionalOn(Missing)Bean은 정상동작하지 않는다. Component Scan 은 alphabetically 이뤄지기 때문에 만약 클래스 이름 따위로 제어하기 싫다면 @ComponentScan({}) 의 순서를 바꾸거나, Aq 클래스의 @Configuration 애너테이션을 떼버리고 ApplicationConfiguration 클래스에 @Import(Aq::class) 를 달아버리면 된다. 역시 이상한건 매한가지지만… . 일반적으로 한 프로젝트 안에서 @ConditionalOn(Missing)Bean 을 사용하지는 않고, (나는 원소스로 서로 다른 인프라에 제공하기 위해 작성한 적이 있다.) 다른 프로젝트를 위해 사용할 라이브러리를 짤 때나 특정 라이브러리를 사용할 때 해당 애너테이션을 쓰는 경우가 있다. 라이브러리를 제공하는 쪽에서는 자신의 config를 로드하게 하기 위해 다음과 같은 방법을 쓴다. | @Enable~ 류의 클래스를 작성해둔다. @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Import(TestPropertyConfiguration::class) annotation class EnableTestProperty . 이러면 DemoApplication 의 컴포넌트 스캔 경로 아래에 @EnableTestProperty 가 달린 configuration 을 하나 만들면 된다. | META-INF/spring.factories 파일을 추가하고, 다음 글귀를 작성한다. org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.whojes.common.config.TestPropertyConfiguration . 이러면 의존성을 추가해주기만 하면 springboot application 이 로딩될 때 autoconfiguration 된다. | . 그래서, 다른 라이브러리를 쓰면서 그 라이브러리에서 생성하는 Bean 에 대해 Conditional 을 걸고 싶다면 . | @Enable~ 로 제공되는 경우 . | @ConditionalOn... 을 사용하는 config 에 직접 달거나, 이것보다 빠른 순서로 ComponentScan 이 되는 클래스에 달아야 한다. | . | auto-config 로 제공되는 경우 . | 나만의 auto-config 를 만든다. | . | ApplicationConfiguration 클래스를 컴포넌트 스캔이 되지 않는 패키지로 옮긴다. | 그리고 @AutoConfigureAfter (TestPropertyConfiguration::class) 를 추가해준다. | 해당 파일을 META-INF/spring.factories 에 추가하여 auto-configure 되도록 한다. - 또는, ApplicationConfiguration 클래스에 @Import(TestPropertyConfiguration::class) 를 붙여준다. | . | . 그리고, 다른 프로젝트에 제공하기 위해 라이브러리를 짜는 경우에는 보통 “네가 만든거 있으면 쓰고 없으면 디폴트로 하나 만들어줄게” 하는 형식일 것인데, auto-config 의 경우에는 META-INF/spring.factories 에 의한 auto configuration 은 메인 스프링부트 앱의 component scan 이후에 진행이 되므로, 크게 고려할 사항은 없다. @Enable~ 의 경우에는… 저렇게 쓰지 말아야한다. 사용하는 쪽에서 @Enable~ 을 어느 클래스에 다느냐에 따라서 달라지기 때문이다. 참고로 @SpringBootApplication 이 달려있는 메인 클래스에 @Enable~ 을 달면 컴포넌트 스캔이 다 이루어진 후에 @Enable~ 관련 스캔이 이루어진다. ",
    "url": "http://localhost:4000/develop/springboot/conditional-on-bean",
    "relUrl": "/develop/springboot/conditional-on-bean"
  },"13": {
    "doc": "첫째",
    "title": "달리",
    "content": "달리는 스코티시폴드의 피가 조금 섞인 아주 귀엽게 생긴 아메리칸 숏헤어 고양이다. 이건 내가 키우고 있기 때문이 아니고 진짜 아주 상당히 귀엽게 생겼다. 생각만 해도 기분이 좋아지는군… 고양이를 10여 분간 쓰다듬으면 하루의 피로가 전부 날아간다는 연구 결과가 있다고 하는데, 지금 당장이라도 달려가서 우리 달리를 쓰다듬고 싶다. 처음 가족이 되었을 때는 달리의 기묘한 행동에 놀란 적이 여러 번이었다. 혼자 가상의 적이라도 상대하듯 집안을 왕복하며 점프하는가 하면 갑자기 이불과 싸우고 휴지와 싸우고 침대맡에서 내 머리에 냥냥 펀치를 날리고 도망가고는 하는 행동들이 그것이었다. 그런 행동들은 대부분 아주 짧은 시간에 호다닥 벌어지기 때문에, 타고난 암살자로써 은밀하게 움직여야만 하는 고양이의 의도와는 다르게 주변의 모든 물건들에 다 크나큰 영향력을 미치며 일어났다. 덕분에 이 친구가 시도 때도 없이 본인의 취향대로 재배치하는 내 집의 물건들을 다시 내 취향으로 재배치하는 일이 나의 일과에서 중요한 부분을 차지하게 됐다. 몇몇 중요한 것들에 한해 재배치가 일어나지 않게 하기 위해 일련의 작업을 진행했는데, 손이 없으면 열 수 없는 쓰레기통을 샀으며(고양이 발로도 열 수 있다는 사실을 나중에 알게 됐다) 나의 여행 기념품들에다가는(이미 밴프에서 사 온 스노볼 하나가 깨진 후에야) 양면테이프를 붙여 책장에 고정시켜놨고 갑 티슈 및 두루마리 휴지를 내 공간에서 제거해야 했다. 지금에 와서는 물론 갑자기 뭐가 부서지는 소리가 나던가 우다다 소리와 함께 밥그릇이 엎어져 사료가 쏟아지는 소리가 나더라도 별반 당황하지 않고 의연해지기는 했다. 녀석이 부숴놓는 모든 것들의 가치가 녀석이 나에게 주는 심적 안정감에 한참 모자라기 때문에, 그저 잠들기 전 한번 와서 핥아주고 가기만 한다면 나는 지친 하루의 끝에라도 기꺼이 엉망진창이 되어버린 집안을 치울 용의가 있다. ",
    "url": "http://localhost:4000/cat/dalee#%EB%8B%AC%EB%A6%AC",
    "relUrl": "/cat/dalee#달리"
  },"14": {
    "doc": "첫째",
    "title": "첫째",
    "content": " ",
    "url": "http://localhost:4000/cat/dalee",
    "relUrl": "/cat/dalee"
  },"15": {
    "doc": "#1",
    "title": "#1",
    "content": "아는 만큼 보인다. 알게 된 이상은 무조건 보이게 되니, 보고 싶지 않음에도 불구하고 뇌는 쉽사리 망각해 주지 않아 계속 보이게 되는 것이 요즘의 피곤한 삶의 주범이다. 나는 ‘좋은 것만 보면서 살아도 시간은 모자라다’는 삶의 방향을 고수하며 살고 있기 때문에 나에게 불행함을 안겨줄 만한 것들은 알게 되는 것을 피하는 경향이 강하다. 그러나 일부 오만한 사람들이 건방지게도 내가 모르는 것들을 본인들이 알고 있다는 자부심에 자꾸 나에게 새로운(나를 불행하게 만들) 것들이 보일만 한 사실을 주입하게 되는 날들이 가끔씩 있다. 내 삶에 하등 도움이 되지 않는 진실들을 마치 뭐 대단한 비밀이라도 되는 양 목에 빳빳이 힘을 주고 말해주는 사람들 덕에 그런 날 내 머릿속은 온갖 안 좋은 감정들로 가득 찬다. 억지로 불러일으켜져 쉬이 잠잠해지지도 않는 열등감과 무기력한 마음가짐 같은 부정적인 감정들은 집에 들어가는 내 발걸음을 무겁게 만든다. 광교의 3년간 아파트 가격 상승률과 내 3년 근로소득, 신장매매계약서도 울고 갈 만큼 많은 서명을 요구했던 내 전세대출 계약서와 동기 A의 증여받은 아파트, 새롭게 알게 된 ‘북창동식’의 의미 등을 생각하며 피곤함과 무기력함에 집 문을 열게 되는데… . 비켜라 이 건방진 놈아 . 그래, 달리는 오만하다. 건방진 달리는 문이 열리면 마중 나와 지나가는 내 다리를 걸려고 잠깐 노력하는 모습을 보이고는, 이내 기지개를 늘어지게 켜고 하품을 큼지막하게 하고 침대 위로 다시 올라가 똬리를 튼다. 비키라는 말에 대꾸는커녕 소리 나는 방향을 쳐다보지도 않는 우리 사랑스러운 달리는 조심스럽게 다가오는 내 손을 지 장난감인 양 쳐내고 물고 해서 기필코 자기 자리를 사수해낸다. 피곤함에 소파에 누워있는 나에게로 다가온 달리는 나를 밟고 지나간다. 별 목적도 없으면서 왜 밟고 지나가지? 건방지게 진짜.. 아, 건방진 고양이가 하루의 피로를 사르륵 날려버렸다. 달리가 가진 온화한 오만함은 삐뚤빼뚤 못난 마음에 불쑥 스스로에게 인생의 화풀이를 하며 내면을 갉아먹고 있는 나에게 그러지 말라고 주의를 환기시켜 주는 것과 동시에 정화, 치유까지 해주니 참 고마운 오만함이라고 할 수가 있겠다. 그래, 건방지더라도 이렇게 온화하게 건방져야지. 덕분에 한참 피곤한 현대인의 삶에서도 에너지를 충전하고 간다. ",
    "url": "http://localhost:4000/cat/dalee/1",
    "relUrl": "/cat/dalee/1"
  },"16": {
    "doc": "#2",
    "title": "#2",
    "content": "혼자 산지 제법 되었다. 오랜 독신 생활로 인해 집안에 혼자 있을 때의 내 차림새와 행동거지는 차마 문명인의 그것이라고 하기에는 무리인 면이 많다. 어차피 아무도 안 보는데 뭐 어때? 하는 생각을 하다가 조용히 나를 관음하고 있는 달리를 마주하는 순간에는… . 달리에게… . 아이고 달리야! 나는 네가 나를 물끄러미 쳐다볼 때마다, 그때 내가 하고 있던 행동에 대해 당위성을 설명해야 할 것만 같은 기분을 느낀단다. 무엇인가를 열심히 하고 있다가 문득 고개를 돌렸을 때 너의 궁금해하는 그 지극히 귀여운 표정과 다소곳이 모은 앞발을 발견하게 된다면 나는 하던 일을 멈추고 당장에 변명을 시작해야 할 것만 같아. 왜 주기적으로 청소기를 돌리는지, 왜 아침마다 네가 그토록 싫어하는 뜨거운 물줄기 속에서 망부석마냥 멍하니 꿋꿋하게 서있는지, 왜 혼자 음정도 괴상한 노래를 흥얼거리고 있는지, 왜 가끔 책상에 앉아 이상한 소리가 나는 동영상을 혼자 보고 있는지. 어쩜 너는 내가 뭔가를 하기만 하면 빤히 쳐다보는 것 같다. 중생아... 그런 행동은 대개 내가 인간이라서 하는 행동이지만, 내가 정작 껄끄러운 건 내가 나이기 때문에 하는 행동들이란다. 그건 어떻게 당위성을 설명할 수 없어. 그러니까, 코를 후비다가 나를 눈도 깜빡이지 않으며 물끄러미 쳐다보는 너를 마주했을 때는 뭘 그렇게 쳐다보냐고, 인간이 코딱지 파는 것 처음 보냐고, 너도 손가락이 없어서 못 팔 뿐이지 파고 싶은 거 내가 다 안다고 일갈할 수가 있지만, 차오르는 감정을 주체하지 못하고 침대와 짐볼에 분노의 주먹질을 날리다가 손목을 접질려버려 부여잡고는 소리를 지르고 있을 즈음 네가 날 그렇게 물끄러미 쳐다본다면, 나는 아무 말도 할 수가 없단다. 어… 좀 모자라 보이긴 하지? 내가 왜 이러고 있냐면… 흠… . 너는 알고 있을까? 사람도 아닌 너 때문에, 그 누구보다도 나의 모든 것을 보고 관찰하고 있는 너 때문에 나의 혼자 있는 시간이 방해된다고 생각하여 가끔은 모두 퇴근한 사무실에 앉아 음악이나 듣다가 느지막이 퇴근하는 날도 있다는 사실을. 아니 내가 내 돈 내고 사는 집인데 왜 너 때문에! 그러니 그렇게 궁금한 표정으로 빤히 쳐다보고 있지 말고 그냥 받아들이고 아까 하던 꼬리랑 싸우기 놀이나 계속하도록 해. 어차피 너는 우리말을 못하니까 설명해 주지도 않을 거고, 게다가 나도 네 모든 행동을 너의 행동이 아닌 고양이의 행동으로 이해하고 있단다. 관음 중 무언가 대단한 것을 발견해 버린 달리 . ",
    "url": "http://localhost:4000/cat/dalee/2",
    "relUrl": "/cat/dalee/2"
  },"17": {
    "doc": "#3",
    "title": "#3",
    "content": "인간사 일과 번뇌는 언제나 차고 넘쳐서, 인간이라면 모름지기 먹고살기 위해서 반드시 하루에 할당된 과업과 고민을 채워야만 한다. 허겁지겁 오늘의 할당량을 맞추기 위해 앉아서 일을 하다가 문득 사방이 고요해졌음을 느끼고 주위를 둘러보면 꼭 시끄럽던 달리가 어디엔가 퍼져서 곤히 잠을 자고 있는 것을 발견할 수 있다. 야 자냐? 아이고 달리야! 나는 이 녀석아 너 츄르 한 개 참치캔 한 통 더 사주려고 이렇게 아등바등 살고 있는데, 너는 은혜라도 갚는 척 쥐라도 잡아서 선물로 바치는 척이라도 해야 하지 않겠니? . 삶을 위해 번뇌에 너무 사로잡히다 보면 삶의 목적이 희미해져 갈 때가 있다. 다급하게 살아가다가 잠시 쉬기 위해 고개를 들면, 머릿속은 온갖 종류의 모호함, 불확실함, 위기감, 무기력감 등이 복잡하게 얽혀 서로 시너지를 일으켜 나는 곧 생각의 구렁텅이로 빠지게 된다. 삶의 목적? 당연히 행복이죠. 아니, 행복을 위해 사는데 이러고 벅차게 살아야 하나요? 그건 미래의 행복을 보장받기 위해 필요한 비용이죠. 그 미래는 대체 언제인가요? 애초에 행복이라는 것이 목적이 될 수 있는 것인지, 삶에 목적이라는 것이 있는지, 아니면 태어났기 때문에 살아가고 있고 이왕 살고 있기 때문에 행복해야 하는 것이 아닐까요? 복잡하고 답이 없는 문제들과 농도 짙은 무기력함이 나의 휴식 시간을 방해하고 있을 바로 그때 뒤를 돌아보면… . 너는 천하태평이구나..! 너는 미래가 걱정되지도 않니? 너도 곧 있으면 정년퇴직당한 후에 치킨을 튀기는 방법을 배워야 할지도 모르는데, 별 생각도 관심도 없어 보이는구나? 하기사, 너는 그 귀여움을 어필해서 어떻게든 빌어먹고 살 수 있을지도 모르겠다. 네가 아이컨택하면서 애옹 울기만 하면 너에게 츄르를 가져다 바치는 사람들이 한둘이 아닐 테니 말이야. 하여튼 너에게도 ‘경축! 하루 종일 아무것도 안 함’ 플래카드라도 하나 만들어 목에 걸어주면 딱 알맞을 것 같다. 보통 많이 자는 고양이는 하루에 스무 시간 정도 잔다고 하는데, 너도 딱 그 정도 자는 것 같구나. 캣타워, 소파, 침대 위, 침대 밑, 컴퓨터 위, 신발장, 피아노 위, 버리려고 내놓은 상자, 어느 한 곳 너의 침대가 아닌 곳을 본 적이 없구나. 그렇게 졸린가? . 나는 이미 저런 류의 무기력한 고민에 대해 필요한 것은 해답이 아니라는 것을 알고 있다. 해답은 없는 것이나 다름없으므로 그저 그 생각들로부터 벗어나는 것만이 유일한 해결책인데, 밀물처럼 몰려드는 생각으로 인해 그로부터 벗어나려는 시도조차 쉬이 허락되지 않는 급박한 상황에 우리의 달리는 그냥 쳐 자빠져 자는 것만으로 훌륭히 그 일을 할 수 있게끔 도와주고 있는 것이다. 그래, 달리의 저 얼빠진 표정을 더 잘 보려면 열심히 과업 할당량을 채워야 하니, 넋 놓고 있지 말고 열심히 다시 일이나 하련다. 켁! 이게 바로 자발적인 노예가 되는 과정인가! . 뻐근 . ",
    "url": "http://localhost:4000/cat/dalee/3",
    "relUrl": "/cat/dalee/3"
  },"18": {
    "doc": "개발",
    "title": "백엔드 엔지니어",
    "content": ". ‘나 개발자요’ 소개하는 직종은 왜 소프트웨어 개발자밖에 없는 것인가? 건방지게시리…. 회사의 목표는 개발이 아닌가? 디자이너도 새로운 디자인 개발 브랜드마케터도 브랜드 개발 공정수율개선도 신공정 개발 스마트폰 출시도 신제품 개발​ 다른 대부분의 직업들도 모두 개발하고있다. ",
    "url": "http://localhost:4000/develop#%EB%B0%B1%EC%97%94%EB%93%9C-%EC%97%94%EC%A7%80%EB%8B%88%EC%96%B4",
    "relUrl": "/develop#백엔드-엔지니어"
  },"19": {
    "doc": "개발",
    "title": "개발",
    "content": " ",
    "url": "http://localhost:4000/develop",
    "relUrl": "/develop"
  },"20": {
    "doc": "다이어리",
    "title": "일기는 마음의 거울",
    "content": ". ",
    "url": "http://localhost:4000/life/diary#%EC%9D%BC%EA%B8%B0%EB%8A%94-%EB%A7%88%EC%9D%8C%EC%9D%98-%EA%B1%B0%EC%9A%B8",
    "relUrl": "/life/diary#일기는-마음의-거울"
  },"21": {
    "doc": "다이어리",
    "title": "다이어리",
    "content": " ",
    "url": "http://localhost:4000/life/diary",
    "relUrl": "/life/diary"
  },"22": {
    "doc": "2021",
    "title": "2021",
    "content": "한 해를 정리하는 마음과, 새로운 한 해를 시작하는 마음가짐.. 2021년에 이룬 것과 이루지 못한 것, 늦은 20대를 지나며 이룬 것과 이루지 못한 것을 나열해보고 또.. 새해에 늘상 하는, 앞으로의 마음가짐을 다지고자 하는 루틴의 일환으로 2021년 한 해를 정리하는 글을 작성해보자 . 근로 . 오랜만에 지인들을 만나 이야기를 하면서 느낀 점이 있다. 카카오 다니는 사람한테 카카오톡 얘기하지 말자.. 아반떼 가지고 상협이와 민석이를 들볶지 말고 갤럭시를 가지고 기현이를 닥달하지 말자. 그래도 예전보다는 많이 나아졌지만, 일반적으로 토스를 사용하지 않는 강한 이유 하나를 가지고 있는 사람이 나에게 토스 어쩌구저쩌구 하지 않냐? 사람들 별로 안쓰지 않냐, 내 주변 아무도 안쓴다 이런 식으로 물어볼 때가 많다. 나는 설득하고 싶은 의지도, 설명하고 싶은 지식도 의지도 없는 사람인데 그렇게 물어볼 때마다 할 말이 없다. 토스 전망이 어때? 나도 몰라... 그런 질문들 보다는 더 답하기 쉽지만, 그리 답하고 싶지 않은 질문들도 있는데, 너 토스에서 뭐함? 이 그렇다. 제품을 담당하지 않는 플랫폼 입장에서 비코딩 인력에게 내가 하는 일을 설명하기란 나한테는 쉽지가 않기 때문이다. 아니, 정확히 말하면.. 대단한 일을 하고 있지만 대수롭지 않은 척 설명하기 어렵다. 듣기에, 그리고 실제로도 그리 크게 대단한 일은 아니기 때문이다. 너 토스에서 무슨 일 해? 그냥.. 개발해 개발.. 아직 나 자신에 대한 자신감이 부족한 편이란 말이다. 아, 이 회사에 온지 어언 2년이 다 되어간다. 아직 2년이 안됐는데 2년이 됐다고 생각하면 진짜 2년이 됐을 때 아 아직 2년밖에 안됐네 하는 생각이 들 것이므로 아직 2년은 안되었지.. 라고 생각해야겠다. 2년 가까이 일하고 보니까 알겠다. 평생직장이라는 개념은 나에게는 정말이지 안맞는 개념이다. 평생 한 직장에서 일을 한다니… 정말 눈물이 앞을 가릴것만 같을 테다. 나는 이 직장에서 2년을 더 해야 한다. 2024(!!)년 4월까지는 근무를 해야한단 말이다. 아….. 빌어먹을 스톡옵션…… . 언제나 멋있는 삶을 사는 사람을 동경해왔다. 지금 이 상황에서, 자신의 실력에 자신이 있는 사람이라면, 까짓거 가지고 있는 스톡옵션 버리고 다른 더 재미있는 일을 찾아갈테다. 그러나, 거기 가면 또 거기의 스톡옵션을 3~4년을 버텨야 하겠지. 오잉? 거기서 2년 지나면 또 나가고 싶을 거 아냐? 허허… 인생사.. 그러나 토스라는 조직이 지겹거나 질리거나 한 것은 아니다. 비바리퍼블리카는, 이정도 규모에서 이보다 더 나에게 딱 맞는 조직은 없을 것이라 자신할 수 있을 만큼 나에게 있어 최고의 직장이다. 아마 이직을 하게 된다면 여기와 비슷한 문화인데 100명 이하 정도 규모의 회사로 들어가겠지? . | 그러니 결국 내가 지금 해야하는 일은? | . 사실 일전에는 언젠가 직접 스타트업을 시작하고자 하는 생각이 있었으나, 가까이서 그 정수를 보고 있자니 아무래도 안되겠다 나는. 실력을 키워서 CTO 로 들어가던가 리드개발자로 들어가서 스톡이나 받아야지 직접 창업은 안되겠는데요? 그러니 내 목표는: 많이 배우고 많이 탐색해서 포스트 승건을 찾아 빌붙을 준비를 철저히 하는 것. 그게 지금의 내가 할 수 있는 최선의 일이다. 다행히도, 이 회사는 내가 배우고자 하고 알아보고자 하면 언제나 활짝 기회를 열어주는 회사이다. 그러니, 많은 것을 준비하자. 경제 . 2021년 한 해의 나는 흔히 말하는 속세의 어른이었다. 그 김수환추기경 이런 어른 말고… 내가 가진 집과 주식의 가격을 주기적으로 관찰했으며, 빌어먹을 세금을 덜 내기 위해 각종 세법을 공부했고, 자산의 포트폴리오를 작성하여 리스크와 리턴을 확인하기 시작했다. 가끔은 부동산 경/공매 유튜브를 보기도 하고, 엔젤투자를 위해 적격엔젤 양성과정을 수료하기도 했다. 즉, 빠르게 경제적 자유를 얻기 위해서 필요한 모든 것들에 관심을 가지기 시작한 것이다. 만약 어른들에게 \"창가에 제라늄 화분이 놓여있고, 지붕에는 비둘기들이 놀고 있는 멋진 붉은 벽돌집을 보았어요...\"라고 말하면 어른 들은 그 집이 어떤 집인지를 상상해내지 못한다. 어른들에게는 \"십만 프랑짜리 집을 보았어요\" 라고 해야한다. 그래야 \"야, 참 멋진 집이겠구나!\" 감탄한다. 생텍쥐베리의 정의에 따르면 나는 어른이 된 것이라고 할 수가 있겠다. 20대의 나는 어린왕자 신봉자였으나, 애석하게도 그의 기준에서는 나는 부정적이고 한심한 어른이므로 이미 어른이 되어버린 바 약간의 반발심으로 인해 메신저를 공격할 수도 있게 되었다. 그러나 나는 생텍형님의 개인사(생택쥐페리는 주변에 여자들이 많았고, 넬리 드보귀에라는 유부녀와 불륜 관계였다. 출처 - 꺼무위키)에 대하여 당시 시대상을 고려하여 개인을 공격하지 않도록 마음먹었으니, 생텍 형님도 어른을 보는 저 부정적인 시선에 대하여 현 시대상을 조금은 고려해주어야 형평성에 어긋나지 않을 것이다. 현 시대상은 무엇인가? 창가에는 제라늄 화분이 놓여있고, 지붕에서는 산새들이 지저귀는 멋진 붉은 벽돌집은 내 로망이긴 하다만, 포기할 수 없는 많은 다른 것들, 예컨대 직장으로 편도 1시간을 초과하지 않을 것, 매일 먹거리를 살 수 있는 마트와 가까울 것, 급하게 아플 때 쉽게 찾을 수 있는 위치에 병원이 있을 것, 아이들의 성장에 유해한 영향을 미칠만한 장소가 없을 것 등은 전혀 설명하고 있지 않다. 이것들은 아이들의 눈으로 볼 수 없는, 김규삼 작가에 의하면 아이들이 오줌지리며 벌벌 떠는 일진보다 수십갑절 무서운 존재라는 사회 에서 필요한 기준으로, 한두 가지로 간단하게 설명을 할 수가 없다. 누가 살고 싶을까? . 근처에 병원이 없어 급성 요로결석 발생시에 응급차가 30분이 걸려 당도하며, 편의점 하나 없어 차를 타고 30분을 나가야 껌 한 통이라도 살 수 있고, 학교가 없어 아이들이 자전거로 한시간을 걸쳐 가야 하지만 바로 옆에 사창가가 있는, 창가에는 제라늄 화분이 놓여있고, 지붕에서는 산새들이 지저귀는 멋진 붉은 벽돌집 . 하지만 숫자는 그 수많은 것을 간단하게 표현해준다. 10만 프랑? 병원도 편의점도 가까이 있고 편리한 사회 인프라를 많이 가지고 있지만 학교는 근처에 없을 수도 있겠구나. 15만프랑? 병원도 편의점도 학교도 가까이 있는 살기 좋은 위치겠구나. 창가에 제라늄 화분을 놓을지 고양이 캣타워를 놓을지, 붉은 벽돌으로 외벽을 장식할 지 판넬을 갖다 붙일지 태양광발전판을 달지는 그 이후의 문제로, 사는 취향 따라 선택하면 그만인 것이다. 나도 창가에는 제라늄 화분이 놓여있고, 지붕에서는 산새들이 지저귀는 멋진 붉은 벽돌집 에서 살고 싶다. 아니, 나는 식물은 좋지만 꽃 종류는 크게 선호하지는 않는 편이어서 제라늄이 아니어도 되고, 달리와 자몽이가 즐길 수 있는, 야경에 어울리는 식물을 찾아 창틀에 올려놓고 싶고, 붉은 벽돌은 약간 올드한 느낌이 난다고 생각하기 때문에 적삼목과 징크 혹은 적삼목과 스타코를 잘 조합한 그런 외벽을 가진 집에서 살고싶다. 그것을 위해서 건강은 제껴두고 피똥을 싸고 있는 것이다. 그러니까, 말마따나, 돈 돈 하면서 사는게 아니라 돈 돈 하면서 살지 않으려고 열심히 돈을 벌고 모으고 굴리는것이다. 돈은 꼭 필요한 것인데, 자본이 돈을 벌어다주지 않으면 결국 내가 돈을 벌어야하는데 이게 돈 돈 하게 되는 길이라는 거지. 아.. 그래서, 종국에 요즘에 드는 생각은, 소유욕에는 끝이 없다. 정말, 끝이 없다. 어느 정도의 자본을 모아야 초연하게 될까? 자본을 모아 초연해지고 나면, 어떤 것에 관심이 가게 될까? 없으면 안될 만큼의 돈, 있으면 좋은 만큼의 돈, 추가로 적재하여 아이한테 물려줄 수 있을 만큼의 돈, 그 사이의 균형 어딘가.. 그래, 아이. 기웅이한테 물어봐야겠다. 아이를 가지면 다음 퀘스트가 줄줄이 생성되는 걸까? 한국에서 아이가 자라면 행복할까? 음.. 내 아이가 행복할까? 음.. 내 아이가 행복해야만 할까? 아이가 행복할지 어떨지 여부는 아이가 결정하게 둘까? 그냥 나 살고싶은 곳에서 살까? . 아니 잠깐, 정말 끝이 없을까? 내가 끝까지 가보지도 않았는데, 어떻게 끝이 없다고 확신할 수 있지? 1억을 가지면 10억을 갖고싶고, 10억을 가지면 100억을 갖고 싶지만, 100억을 가지면 아 만족~ 할 수도 있는 거잖아? 맞아 그렇네… 우선 달려야겠다. 어디까지? 나도 몰?루ㅋ . 건강 . 2021년은 정말이지 건강을 챙기지 않은 한 해였다. 2020년 만 28세 시절의 건강검진에서 나는 고지혈증, 역류성 식도염, 지방간, 위 미란을 선고받은 바 있으며, 그것이 두려워서 2021년에는 건강검진 조차 받지 않았다. 이렇게 해선 안된다. 건강을 잃으면 위의 것들이 다 무슨 소용이랴? 이번에 방학으로 일주일을 쉬면서, 이런 저런 생각을 했다. 그리하여, 2022년의 다짐 . | 날 풀리자 마자 건강검진 | 일주일에 최소 3번 한시간씩 운동을 하기로 | 근무시간을 앞당겨서 (10 to 10 정도로) 취침을 앞당겨 건강을 회복 | 건강한 음식 먹기 . | 3끼 챙겨먹기 | 저녁에는 가볍게 먹고 야식 먹지 않기 | . | . 이거 나열하고 보니깐 그냥 1월 1일에 항상 하는 그런 것 같은데, 그런 거 아니다. 지킬거다. ",
    "url": "http://localhost:4000/life/diary/2021",
    "relUrl": "/life/diary/2021"
  },"23": {
    "doc": "2022",
    "title": "2022",
    "content": ". | February | January | . February . | 5일 토요일 늦은 오후, 날씨는 매우 추움 🥶 | . 빠르게 경제적 자유를 획득하고 싶은데, 경제적 자유를 획득하는 것이 목적인 삶이 되어버리는 것 같다. 전생에 유대인이었을까? 아니면 뒤늦게 시작한 돈놀이 공부가 적성에 맞는 걸까? . 경제적 자유를 얻고 나면, 수능을 다시 쳐서 경제학과에 입학해 경제학을 깊게 공부해보고 싶다는 생각을 종종 한다. 평생 공부하는 세상이라고 하지만, 공부를 재밌게 여길 수 있는 능력을 타고난 건 축복이라 하겠다. January . | 3일 토요일 밤, 날씨는 매우 추움 🥶 | . 달콤한 일주일의 겨울방학이 끝나간다. 끝-나간다. 끝이 나갔는데 왜 끝이 보이지.. 열흘동안 이것 저것 하려고 생각했으나, 날도 많이 춥고 생각보다 일로 인해 쌓여있던 피로도가 높아 결국 내내 푹 쉬기만 했는데 만족도가 꽤 높았다. 나는 쉬었어야 했던 것이다. 다음 번 긴 휴식은.. 다음 겨울방학 열흘, 그리고 내년에 사용할 리프레시 휴가.. 또 달리자. 이번엔 건강도 신경쓰면서ㅎ . ",
    "url": "http://localhost:4000/life/diary/2022",
    "relUrl": "/life/diary/2022"
  },"24": {
    "doc": "double curly braces",
    "title": "double curly braces",
    "content": "java 에서 인터페이스만 익명클래스로 생성 가능한 줄 아랐다. // interface public interface Car { String getMaker(); String getModelName(); } public class Main { public static void main(String... args) { Car car = new Car() { @Override String getMaker() { return \"whojes\"; } @Override String getModelName() { return \"model\"; } }; } } . 근데 클래스도 익명클래스로 만들 수 있었따! . public class Car { private String _maker; private String _modelName; public Car(String maker, String modelName) { this._maker = maker; this._modelName = modelName; } protected void setMaker(String maker) { this._maker = maker; } } public class Main { public static void main(String... args) { Car car = new Car(\"whojes\", \"model\") {{ setMaker(\"not whojes\"); }}; } } . 요래 double curly braces 하면 익명 클래스의 객체가 되고, 이 안에는 세컨더리 컨스트럭터로 동작한다. 그래서 아니 이게 뭔가, 싶어서 조금 찾아봤는데.. 동작 설명 . https://stackoverflow.com/questions/1958636/what-is-double-brace-initialization-in-java . 동작 원리는 대충 이렇게 된다고 한다. | The first brace creates a new Anonymous Inner Class. These inner classes are capable of accessing the behavior of their parent class. | The second set of brace creates an instance initializers like static block in Class. If you remember core java concepts then you can easily associate instance initializer blocks with static initializers due to similar brace like struct. Only difference is that static initializer is added with static keyword, and is run only once; no matter how many objects you create. | . 우선 첫번째 braces 는 익명 이너클래스를 만드는것 =&gt; interface 에서만 되는 줄 알았는데, 클래스로도 되잖아! 정말 나는 아는게 없군? 두번째 braces 는 스태틱 초기화블록과 비슷하게 초기화 블록의 역할을 한다. 다만 스태틱과 다르게 인스턴스 초기화에 사용될 뿐.. 즉, 특별하게 존재하는 구문은 아니고 다음 표현에서 인덴트를 제거한 것이다. class Car { ... } class Main { public static void main(String... args) { Car car = new Car() { // 익명 이너 클래스 { this.setSomething(\"crazy\"); } }; System.out.println(car.getClass().getName()); // Main$1 } } . 그러나… . https://jesperdj.com/2016/07/19/dont-use-the-double-brace-initialization-trick/ . 간단히 하면 이 일명 익명 초기화 블록 은 직렬화 혹은 가비지 컬렉팅 과정에서 문제가 될 수 있는데, 이렇게 익명 인스턴스를 만드는 블록에서 어느 클래스 인스턴스 A의 어느 메서드를 사용한다 치면, 한 번 사용하고 버려지더라도 익명 인스턴스에서 그 메서드의 레퍼런스를 들고 있는 꼴이 돼서 그 인스턴스 A 는 더이상 사용되지 않더라도 가비지 컬렉션의 대상으로 선택되지 않는다고 한다. 즉, 메모리 릭이 발생하는데.. 잘 쓰면 되겠네 그럼.. 은 아니고.. 단순한 환경에서 잘 알고 사용한다 치더라도 잠재적인 문제를 야기한다 하니 우선은 지양하는걸로.. 젠장 모멘트 . First of all, it is a trick, which means that the code is obscure – if you’ve never seen this before, it’s hard to quickly understand what is happening. Especially less experienced developers will be baffled by the {{ and }} and might think that these are tokens with special significance. Also, instance initializers are a seldom used Java feature, which many developers won’t have seen before. ㅋㅋㅋ 젠장.. ",
    "url": "http://localhost:4000/develop/java/doublebraces",
    "relUrl": "/develop/java/doublebraces"
  },"25": {
    "doc": "에세이",
    "title": "글쓰기",
    "content": " ",
    "url": "http://localhost:4000/life/essay#%EA%B8%80%EC%93%B0%EA%B8%B0",
    "relUrl": "/life/essay#글쓰기"
  },"26": {
    "doc": "에세이",
    "title": "에세이",
    "content": " ",
    "url": "http://localhost:4000/life/essay",
    "relUrl": "/life/essay"
  },"27": {
    "doc": "#1",
    "title": "#1",
    "content": "내가 겪은 대인관계의 성숙은 대부분 단념으로써 이루어졌다. 모든 일이 내 기대와 상식에 부합할 것이라는 생각, 모든 사람의 행동이 내가 이해할 수 있는 범위 내일 것이라는 생각, 모든 일과 행동에 이유가 있을 것이라는 생각, 그리고 그 이유가 밝혀져서 내가 알아야만 한다는 생각 모두 나의 안일한 희망사항이었을 뿐이고, 결국엔 포기해야만 하는 생각들이었다. 이 일련의 포기를 ‘성숙’이라는 단어를 사용해 표현해야 하는 것이 썩 내키지는 않지만, 뭐 어떠랴. 이해할 수 없는 일들로 골머리 앓으면서 ‘어쩜 나에게 이럴 수 있지? 나를 어떻게 생각하는 거지?’ 하는 답이 없는 고민을 지속적으로 하는 것보다는 간단히 단념해서 내가 이해할 수 있는 범위 밖의 일들은 그냥 그런가 보다 하고는 넘어가는 것이 나를 괴롭히지 않는 길이며 괴로움에 자멸하지 않는 지름길이라고 생각하면 ‘성숙’이라고 표현하는 데에 부담이 없겠다. 관계를 시작하는 것보다 관계를 끊어내는 게 더 어렵다는 것을 어렴풋이 깨닫게 되는 때가 있다. 끊어내는 것이나 끊김 당하는 것이나 고통스럽긴 매한가지겠다만, 끊어진다는 사실의 괴로움과는 별개로 그 방아쇠를 당겨야 하는 것에 대한 부담감이 상당하기에 더 어려움을 느끼게 되는 것이다. 모든 사람에게는 그만의 상처가 있다지만, 내가 상처를 내버리고 말 수도 있다는 사실은 그리도 무서운 것인지 어떻게 요리조리 잘 피해서 상처가 안나는 결으로 칼질을 조곤조곤해갈까 노심초사하다 결국에는 전 방위로 칼집을 내서 상처투성이로 만들어버리고야 마는 그런 결론이 기다리고 있지는 않을까 두려워 어쩌지 못하고 결국엔 지지부진하게 관계를 이어가기도 한다. 개중에는 방아쇠를 채 당겨내지 못하고 관계를 끊어버리는 사람들도 있는데, 어렵다는 이유가 그 행위를 정당화해주지는 않는다. 정말로 공들여서 탑을 쌓았으면서, 왜 스스로 무너뜨리지도 못하고 그냥 두고 떠나가는지. 그 공들여 지어진 탑은 폐허가 되어 꿋꿋이 그곳에 서있어 새로운 탑이 들어서지도 못하고 서서히 풍화되어 어쩌면 운이 나빠 그 땅까지 오염시킬지도 모르는데 말이다. 관계의 끝에는 무엇이 됐든 자기만의 장례식을 치러야 하는 법인데, 그 선택마저 제한당한 채 영문을 모르고 희망과 절망 사이를 왕복하며 무너지지 못하고 서서히 풍화되어 가는 탑이 되는 기분은 착잡하기 이를 데 없다. 나도 한때는 공들여 지어진 탑이었는데. 이러나저러나 단념하는 수밖에 없다. 폭풍같이 분노하던 예전 시절에 비해 조금 덜 살아있는 사람 같아 보일 수도 있겠다만, 이제는 지속적으로 나를 갉아먹어도 건강할 만큼 정신이 단단하지 않으므로 적당히 단념하고 내가 이해하거나 어쩔 수 있는 것이 아닌 부분에 대해서는 분노건 슬픔이건 간에 흘려보내버려야 한다. 그리고 내가 대처할 수 있는 부분에 대해서는, 오만가지 이별 음악을 듣던 영화를 보던 음주가무를 하던 밤새서 게임을 하던 내가 원하는 방식으로 장례식을 치러주면 되겠다. ",
    "url": "http://localhost:4000/life/essay/1",
    "relUrl": "/life/essay/1"
  },"28": {
    "doc": "etc",
    "title": "기타",
    "content": " ",
    "url": "http://localhost:4000/develop/etc#%EA%B8%B0%ED%83%80",
    "relUrl": "/develop/etc#기타"
  },"29": {
    "doc": "etc",
    "title": "etc",
    "content": " ",
    "url": "http://localhost:4000/develop/etc",
    "relUrl": "/develop/etc"
  },"30": {
    "doc": "유럽",
    "title": "유럽 초심자의 여행기",
    "content": " ",
    "url": "http://localhost:4000/travel/europe#%EC%9C%A0%EB%9F%BD-%EC%B4%88%EC%8B%AC%EC%9E%90%EC%9D%98-%EC%97%AC%ED%96%89%EA%B8%B0",
    "relUrl": "/travel/europe#유럽-초심자의-여행기"
  },"31": {
    "doc": "유럽",
    "title": "유럽",
    "content": " ",
    "url": "http://localhost:4000/travel/europe",
    "relUrl": "/travel/europe"
  },"32": {
    "doc": "Java filer",
    "title": "Java filer",
    "content": "구글 검색하면 자꾸 Filter 아니냐고 내가 원하는 결과는 감춰서 보여주는 Filer. 기존 Annotation processing 개발 시에 진짜 아무것도 모르고 개발을 해서 컴파일 시간이 과하게 길었었는데, 이번 기회에 제대로 공부하여 수정하기로 마음먹었다. ​ AbstractProcessor를 상속할 경우에 구현해야 하는 init의 파라미터 ProcessingEnvironment는 많은 툴을 제공해준다. Type 관련 유틸, Element 관련 유틸, Messager, Filer 등을 제공해줘서 프로세싱 할 때 유용하게 사용할 수 있다. private Elements elementUtils; private Types typeUtils; private Messager messager; private Filer filer; @Override public synchronized void init(ProcessingEnvironment env) { super.init(env); this.elementUtils = env.getElementUtils(); this.typeUtils = env.getTypeUtils(); this.messager = env.getMessager(); this.filer = env.getFiler(); } . jvm 은 자바 소스코드를 클래스파일로 컴파일 할 때 영어로 적힌 소스 코드를 마크업 언어 정도로 해석한다. 모든 line은 Element이고, 각각의 속성에 따라 엘러먼트의 타입이 있다. 가령 . package com.example; // PackageElement public class Foo { // TypeElement private int a; // VariableElement private Foo other; // VariableElement public Foo () {} // ExecuteableElement } . 이런 식이다. elementUtils 는 이 Element를 잘 조작할 수 있게 도와준다. public class Foo 라는 것은 TypeElement 이고, 이는 그 자체로는 Foo 라는 클래스의 정보를 갖고 있지 않다. TypeElement.asType() 메서드는 TypeMirror 클래스의 객체를 리턴하며, 이 타입미러가 Foo 라는 클래스 타입의 정보를 가지고 있고, typeUtils 는 이 타입미러를 잘 조작할 수 있게 도와준다. (타입미러는 Java의 타입을 나타내는 클래스로, 타입이라 함은 primitive types, declared type(class/interfaces), array types, type variables, null 등 모든 타입을 포괄하는 개념이다.) messager 는 메세지를 잘 예쁘게 꾸며서 내보낼 수 있는…그런… ​ 이 글을 왜 쓰냐하면, 개인적인 깨달음이 있었기 때문이다. 새로운 것을 배울 때는 끝까지 배우고 쓰자! 하는 마인드가 바로 그것인데, 나는 보통 새로운 것을 배울 때 ‘오 이렇게 하면 되네! 여기에 내가 아는 이만큼을 추가하면 이렇게 할 수 있겠네!’ 로 하기 때문에 매뉴얼을 덜 읽고 코딩을 하는 모양새가 됐었기 때문이다. 뭔 말인고 하니, 아! AbstractProcessor 를 상속하고 process 메서드 안에 코딩을 해놓으면 컴파일때 작동하네! 하고는 끝까지 안 읽고 그냥 일반 FileWriter로 파일을 쓰고, 그 때 쓴 파일은 컴파일이 안되니 전체 컴파일을 다시 하고, 그러다보니 빌드타임이 무진장 길어지고, … . AbstractProcessing 에서 SourceGen을 위한 javax.annotation.processing.Filer 클래스가 있다. Filer.createSourceFile의 인자로 full classname 을 넣어주면 javax.tools.JavaFileObject 객체가 생기는데, 이 객체로 file write를 하면, 빌드디렉토리의 generated/sources/annotationProcessor/java/main/ 디렉토리 하위에 소스파일이 생기게 되고, 여러 번의 라운드가 끝나고 나서야 src/ 하위 및 build/generated/source/ 하위의 소스들이 컴파일되어 바이트 코드가 된다고 하네. 애너테이션 프로세싱은 한 빌드에서 여러 라운드를 돈다. filer로부터 생성된 파일이 또다시 프로세싱 해야 하는 애너테이션을 달고 있을 수도 있으니 한 프로세스에서 새로 생긴 파일들만 input으로 하여 다시금 processing을 한다. 내가 했던 기묘한 짓, 즉 빌드디렉토리가 아닌 소스디렉토리에 소스파일을 생성하고는 파일이 없으면 생성, 있으면 클래스파일 생성 후 파일 삭제 하도록 로직을 짠 후 컴파일을 총 두 번 했던 짓은 쓰레기같은 짓이라는 점이다. 이 사실을 알게 된 후가 되니 누군가 내가 했던 것처럼 코드를 짜놨다면 개쓰레기같이 코드를 짰다고 생각할 만한 개짓거리다. 아, 이거 깃헙에 소스 올려놨는데, 진짜로 소스공개 할 때는 하늘에 한 점 부끄러움이 없을 때만 공개해야한다는 깨달음을 얻어버리고 말았다. ​ 그까짓 것 잊어버리고, 다시 Filer로 돌아와서, Filer에서는 createClassFile, createResource, createSourceFile 세 가지의 비범한 메서드들을 제공한다. createResource 는 첫번째 인자로 javax.tools.FileManager.Location 을 받는데, 이넘으로 정해져있는 패스 외의 다른 경로를 사용하는 법을 결국 찾지 못해 어차피 컴파일 할 파일들도 아닌데 그냥 java.nio.File 로 사용하였다. createSourceFile 은 나는 2줄정도밖에 되지 않는 소스코드로 그냥 스트링으로 만들었으나, https://github.com/square/javapoet 에서 제공하는 JavaPoet 클래스를 이용하여 더욱 쉽게 자바 소스파일을 생성할 수 있다고 하니 심심하면 사용해보도록 하자. Hello, JavaPoet 을 출력하는 HelloWorld.java 파일을 자동생성하는 소스코드. (exiting)이 붙어있는 설명이 인상적이다. createClassFile 은 바이트코드를 그대로 작성하여 클래스파일을 직접 만든다는건데, kapex의 말에 따르면 웬만한 경우에 굳이 그럴 필요가 없을 것이고, 그는 꼭 그래야만 한다면 이런 질문을 작성할 수준으로는 안된다고 완곡하게 일침을 가했다. stack overflow . Filer에서 작성된 소스코드는 컴파일 시에 자동으로 함께 컴파일된다고 하니, 내가 했던 쓰레기짓은 다시는 저지르지 않도록 하자. ",
    "url": "http://localhost:4000/develop/java/filer",
    "relUrl": "/develop/java/filer"
  },"33": {
    "doc": "재테크",
    "title": "재테크",
    "content": " ",
    "url": "http://localhost:4000/life/finance",
    "relUrl": "/life/finance"
  },"34": {
    "doc": "둘째",
    "title": "자몽이",
    "content": "자몽이는 고양이라기엔 너무나 애교가 많은 생명체다. 달리가 나름 애교가 있는 고양이라고 생각했으나, 둘째를 들인 후에 생각이 완전히 달라졌다. 이 녀석은… 아, 생각만 해도 너무 귀엽다. 생긴 것은 달리에 못미치지만 (자몽이를 보고 나서야 달리의 얼굴 특징이 보이기 시작했다.), 촉촉한 코와 콩알같은 젤리, 새까매서 잘 보이지도 않는 이 녀석이 발치에서 슬리퍼를 괴롭히고 있는걸 보면… . 한 3~4개월령 까지만 해도 항상 잘 때 사람 위에 올라와서 잤고, 지금까지도 사람 옆에서만 잔다. 아무리 귀찮은 짓을 해도 이빨을 보인 적이 없고 (발톱은 아주 많이 보여줌), 다른 일에는 관심 없고 정말 놀고 싶어서 미쳐버린 아이를 보는 것 같아 달리와는 굉장히 다른 생명체를 키우는 것 같다. 이 고양이놈들이 이렇게 성격이 다르다는게 너무 재밌어서, 계속해서 들이게 되거나 사람에는 관심없고 고양이만 챙기는 캣대디가 되지는 않을까 우려스럽긴 하지만, 아! 그래도 정말 너무 귀엽다… . 달리랑 사이가 그렇게 좋지는 않다. 자몽이의 어마어마한 관심과 장난끼, 하악질을 당해도 전혀 물러서지 않는 모습에 달리가 학을 떼고 잘 다가서지를 않는다. 달리는 워낙에 조심성이 강하고 조용히 신중하게 다가가는 성격인데 반해 자몽이는 정반대여서 초반에는 달리가 어느정도 스트레스를 받았었으나, 지금은 자몽이도 나이가 많이 차고, 하악질에도 어느정도 주눅드는 모습을 보여주면서 조금씩 가까워지고 있다. 낮시간에는 꽤 가까운 거리에서 햇볕을 받으면서 자는 모습을 보여주고 있으니, 조만간 더 친해지지 않을까 싶다. ",
    "url": "http://localhost:4000/cat/second#%EC%9E%90%EB%AA%BD%EC%9D%B4",
    "relUrl": "/cat/second#자몽이"
  },"35": {
    "doc": "둘째",
    "title": "둘째",
    "content": " ",
    "url": "http://localhost:4000/cat/second",
    "relUrl": "/cat/second"
  },"36": {
    "doc": "git",
    "title": "About git",
    "content": "Git 은 일하는 데에 아주 큰 도움이 되니깐 열심히 공부해둬야 한다. ",
    "url": "http://localhost:4000/develop/git#about-git",
    "relUrl": "/develop/git#about-git"
  },"37": {
    "doc": "git",
    "title": "git",
    "content": " ",
    "url": "http://localhost:4000/develop/git",
    "relUrl": "/develop/git"
  },"38": {
    "doc": "집",
    "title": "집",
    "content": "재테크 . ",
    "url": "http://localhost:4000/life/finance/1",
    "relUrl": "/life/finance/1"
  },"39": {
    "doc": "whojes?",
    "title": "What’s new?",
    "content": ". | 2022-02-05 . | 꿈은 환상과 노력.. 노력은 제끼고 환상만 가지고 어언 십여년, 환상은 현실과의 차이가 제법 방대해졌다. | . | 2022-01-01 . | 나는 아직 스물아홉이다. 만나이가 대한민국에도 정착할 수 있도록.. | . | 2021-11-07 . | 서른쯤 먹었으니 다시 생활계획표를 써 보는건 어떨까 생각했다. | . | 2021-10-10 . | 원래 블로그같은 건 이직 시즌에나 쓰는거지만, 인생의 기록을 위해 한 번 시작해보기로 했다. | . | . ",
    "url": "http://localhost:4000/#whats-new",
    "relUrl": "/#whats-new"
  },"40": {
    "doc": "whojes?",
    "title": "whojes?",
    "content": " ",
    "url": "http://localhost:4000/",
    "relUrl": "/"
  },"41": {
    "doc": "java/kotlin",
    "title": "java/kotlin",
    "content": " ",
    "url": "http://localhost:4000/develop/java",
    "relUrl": "/develop/java"
  },"42": {
    "doc": "kafka consumer health",
    "title": "kafka consumer health",
    "content": "k8s 에서 서빙중인 pod 에 각각 사이드카인 envoy 가 붙어있다. L7 filter 용도로 쓰고있어서, 서비스 컨테이너로 패킷이 전달되기 전에 사이드카에 먼저 들렀다가 나가는데… . kublet 이 pod 에 shutdown hook 을 날리게 되면, envoy 컨테이너와 서비스 컨테이너가 같이 셧다운 훅을 받는다. 서비스 컨테이너(여기서는 톰캣)는 셧다운 훅을 받고 하던 일을 차례로 정리하기 시작한다. envoy 컨테이너는 자신이 서비스 컨테이너가 내려가기 전에 먼저 내려가게 되면 서비스 컨테이너로 패킷이 가는 길이 막히기 때문에 서비스가 의도하지 않은 상태에서 500 service unavailable 상태가 될 수가 있기 때문에, 서비스 컨테이너의 헬스를 체크해서 unhealthy 상태가 되면 서비스를 내린다. 참조 . api 서빙과 kafka consuming 을 동시에 하는 서버가 있다. 정상적으로 동작하고 있던 서버를 내린다고 했을 때 . | api 트래픽을 뺀다. (ingress야 힘을 내) | 어플리케이션에서 graceful shutdown 을 한다. (shutdown hook) . | api 트래픽은 앞에서 빼줬으니, 컨슈머 빈과 디펜던시 걸려있는 애들을 정리한다. | 컨슈머 빈을 포함한 bean 들이 destroy 가 끝나면 health check path 의 status 를 unhealthy 로 변경한다. | . | 끝! 별 문제 없이 깔끔하다. | . 그러나 아직 부팅이 끝나지 않은 상태의 pod 에 셧다운 훅이 들어오게 되면 다음과 같은 이상동작이 발생할 수 있다. | bean initialize - kafka consumer bean initialized, auto startup (AbstractMessageListenerContainer 의 default 동작) 되어서 일하기 시작함 | shutdown hook 들어옴 | 전체 bean initialize 가 아직 완료는 되지 않아서 (혹은 완료 되어도 health on 하기 전이라서) health 는 들어오지 않음 | envoy 가 service unavailable 으로 판단, outbound traffic 을 내림 | 카프카 컨슈머에서 외부로 api 호출을 하는 부분이 있다면, 바로 막혀버림 | . 그래서, 결국 kafka consumer bean 의 라이프사이클을 container 의 health 라이프사이클과 맞춰줄 필요가 있다. auto-startup 옵션을 꺼주고, org.springframework.boot.context.event.ApplicationReadyEvent 를 받아서 그때 startup 을 해주면 문제 끝~ . @Bean fun kafkaListener(): KafkaListenerContainerFactory&lt;ConcurrentMessageListenerContainer&lt;String, String&gt;&gt; { return ConcurrentKafkaListenerContainerFactory&lt;String, String&gt;().apply { setAutoStartup(false) ... } } @Bean fun startupHandler(listeners: List&lt;MessageListenerContainer&gt;): ApplicationListener&lt;ApplicationReadyEvent&gt; { return ApplicationListener { listeners.forEach { it.start() } } } . spring boot 버전에 따라 KafkaListenerEndpointRegistry 빈으로부터 해당 작업 (messageListenerContainer.start()) 을 진행해 줘야 할 수도 있다. ",
    "url": "http://localhost:4000/develop/springboot/kafka-consumer-health",
    "relUrl": "/develop/springboot/kafka-consumer-health"
  },"43": {
    "doc": "kubevirt",
    "title": "kubevirt",
    "content": "Kubevirt 가 뭘까? 아! kube 클러스터에서 libvirt를 사용할 수 있게 하는 모델이구나! VM을 kube cluster 에 띄우고 싶다 이거지. 이름 한번 간결하고 좋다. 어떻게 모듈을 붙일까? 하고 보니 Operatorhub.io 사이트에 당당히 이름이 올라있구나. 우선 Operator lifecycle manager 를 설치하고 허브에서 kubevirt operator 를 설치하면 간단하겠구나. ​ . Operator 는 kube 에서 서드파티 앱들을 위해 제공하는 패턴으로, 커스텀 컨트롤러를 제작하는데 사용한다. 컨트롤러라 하면 kube 에서 declarative 명령으로 제시되는 desired state 를 유지시킬 때 사용되는 kube Object 를 일컫는다. 가령 Kind: ReplicaSet 을 보면, ReplicaSet 이라는 컨트롤러가 해당 yaml에 명시되어있는 state 를 꾸준히 돌도록 해준다. 이 이미지의 pod 를 3개 유지해줘 하고 요청하면 다음과 같은 과정으로 그 상태를 꾸준히 유지하도록 해준다. ​기본적으로 제공되는 컨트롤러(pods, services 등의 kube 기본 오브젝트를 제어) 외에 application specific 하게 kube 를 운영할 수도 있는데, 이 때 사용하는 것이 CRD(custom resource definition) 과 Operator 패턴이다. kube 에 ceph 를 운용하고 싶다고 하면 osd는 몇 개가 있어야하고 mon 몇 개가 있어야하고… 하는 특정 application 에 특화된 custom resource 를 정의하고 그대로 유지하도록 도와주는 것이지 (Rook ceph 프로젝트 참조). 비슷하게 kubevirt 는 libvirt 와 kvm 을 이용하게 할 수 있도록 도와주는 crd 와 operator 를 제공하는 놈인 것이겠지. 인터넷에서 찾은 구조인데, kubect\"i\" 를 보고 신뢰도가 떨어진 이미지. 구조를 얼추 보니, kvm hypervisor를 제어하는 libvirtd를 이용하여 VM을 띄우면서, kube 의 선언적 desired state 를 유지하기 위해 각종 구성요소를 pod 으로 띄우고 그 pod가 VM을 띄우는, 그러니까 VM을 kube가 직접 제어하는 것이 아니고 VM 를 제어할 수 있는 각종 모듈을 kube가 제어할 수 있도록 Virt API 를 구성해서 kube 에 붙여놓은 그런 구조로 보인다. 구성요소: . | virt-api-server . kubernetes 의 api server 와 연동하는 api 서버. kubevirt 와 관련된 명령어가 kubectl 을 통해 들어오면 kube api server 는 해당 명령어를 virt-api-server 로 보내 수행. kubevirt 의 메인 엔트리포인트로 사용되고, vm 의 초기화 및 유효성 검사 등을 담당. | VMI . kubevirt 의 CustomResourceDefinitions 중 하나. VM이 사용하는 모든 properties를 필드로 가질 수 있다. 가령 Machin type, Cpu type, amount of RAM/vCPUs, number and type of NICs, … 등의 명세를 가진다. | virt-controller . kube의 libvirt 특화 custom controller 로, virt-handler 및 virt-launcher pods를 관리하는 놈이다. | virt-handler . DaemonSet 으로, kubevirt 설치 시에 모든(혹은 클러스터 중 vm 이 구동될 일부) 노드에 뜨는 pod. vm 자체는 kube 와 관련이 없으므로 kubelet 이 담당하고 있는 watching changes 역할을 vm에 대하여 수행하고 있음. required desired state 를 만족하게 하기 위한 것들을 모두 관찰하는 놈. | virt-launcher . VM 프로세스가 사용할 cgroup 및 namespace 를 지정해놓는 요소. 이 런쳐가 가진 cgroup 및 namespace 를 이용하여 VM 이 뜬다. virt-handler 가 vm 상태를 관찰하고 하다가 수정/생성/삭제 요청을 virt-launcher 에게 날리면 런처가 그 요청을 받아 VM을 제어한다. | libvirtd instance . 모든 VM pod 에 들어 있는 기본 container. 컨트롤러든 핸들러든 런쳐든 libvirtd 가 필요하니깐… . | . Default Procedure: . | client 는 VM 명세가 담긴 VMI 를 만든 후 apply 해서 custom resource를 create 한다. | virt-controller 는 VMI 오브젝트가 생성된 것을 확인하고 해당 명세에 맞는 pod (virt-launcher) 를 만들고, k8s 에서 스케쥴링 해준다. | virt-controller 는 pod 이 생성된 것을 보고 VMI 오브젝트에 nodeName 필드를 업데이트해주고, virt-handler 으로 관할을 넘김 . | virt-handler 는 자기 노드에 k8s 가 VM 파드를 할당한 것을 확인하고, VMI 스펙에 명시된 대로 correspondind libvirt domain 을 형성하도록 virt-launcher 에 signal 을 보낸다. ​ . | . 스토리지 및 네트워크 관련해서는 KubeVirt 에 직접 있는 것이 아니고 다른 모듈들을 붙여서 사용할 수 있다고 명시되어 있으나, 내 생각에 이대로 따라하면 백프로 안되고 수많은 시행착오를 거쳐야 할 것 같은 수준으로 문서가 되어있었다. 두려우니 시도는 나중에…. 즉, 피치 못할 사정으로 인해 vm 을 띄우고 싶을 때도 kubevirt를 이용해 구성해놓은 kube cluster 에 띄우고, 선언적 명령을 지켜주는 환경에 편입시켜 관리를 편하게 할 수도 있게 만들어주는 것이다. VM에 대한 수요는 어쩐지 모르겠으나, Operatorhub.io 에 있는 다른 샘플들보다는 훨씬 더 kube의 근본에 영향을 줄 수 있는 플러그인으로 보인다. 어쩌면 일개 CRD/Operator 가 아니라 kube 속으로 직접 편입할 수도 있을 것 같은 모듈이라고 생각된다. 구글 트렌드 검색을 보면 그건 요원해 보이기는 하지만. ",
    "url": "http://localhost:4000/develop/study/kubevirt",
    "relUrl": "/develop/study/kubevirt"
  },"44": {
    "doc": "일상",
    "title": "일상 이야기",
    "content": " ",
    "url": "http://localhost:4000/life#%EC%9D%BC%EC%83%81-%EC%9D%B4%EC%95%BC%EA%B8%B0",
    "relUrl": "/life#일상-이야기"
  },"45": {
    "doc": "일상",
    "title": "일상",
    "content": " ",
    "url": "http://localhost:4000/life",
    "relUrl": "/life"
  },"46": {
    "doc": "OpenID Connect",
    "title": "OpenID Connect",
    "content": "개념을 이해하기전엔 혼란스러웠는데, . | 원래의 OAuth(RFC 6749, 2.0) 는 네아로, 네이버 아이디로 로그인 기능을 위한 프로토콜이 아니다. | . 네아로 개발자 api 페이지를 가보면 OAuth2.0을 구현했다고 해서 그런가보다 하고 쓰고 있는데, 뭔가 아무리 생각해도 어딘가 조금 납득이 안가는 부분이 있었는데, 이 깨달음을 얻은 후에야 비로소 OAuth로 구현된 네아로 기능의 면면을 확실하게 살펴볼 수 있었으니, 진즉에 공부했어야 마땅했다. OAuth . 그러니까, OAuth가 나오기 전에는, 이런 일이 있었단다. 그... LinkedIn 사이트에서 이제 이메일을 통해 친구추가를 할 수가 있었는데, 그 이메일을 하나 하나 입력해주기 어려우니까 google의 계정에 등록되어있는 이메일을 끌어다가 가져와서 등록해주겠다, 하는 기능이 있었다. 어떻게? ㅋㅋ google의 id/pwd를 나한테 줘! 그럼 내가 그 아이디로 로그인해서 주소록만 보고 다시 로그아웃할게! 하고 링크드인이 제공한거지. 그리고 실제로 그렇게 해서 적용을 했단다. 이 방법은 딱 보기에도 링크드인이 내 계정을 가지고 진짜로 주소록만 보고 닫을거라는 기이한 확신이 있어야만 가능한 짓인거지. 그래서, OAuth가 등장했다. 링크드인에게 구글 계정 접속정보를 넘겨주는 것이 아니라, google에서 로그인을 한 후에 google이 가지고 있는 resource에 접근할 수 있는 특정 권한, 진짜로 딱 필요한 권한만을 가지고 있는 access token(여기서는 내 주소록에 접근할 수 있는 권한)을 링크드인에게 전달하면 링크드인은 그 토큰을 가지고 google에서 허가된 정보만 받아올 수 있도록 합리적이고 안전하게 구성해 놓은 프로토콜이 바로 OAuth다. ​ . 링크드인은 구글 계정정보를 받는게 아니라 작은 창으로 구글 로그인 창(구글 서버에서 제공)을 띄워주고, 유저는 구글에 로그인을 하고, 구글은 유저에게 ‘링크드인이 주소록 정보를 요청하는데 줄거야?’ 하고 물어보고, 주자! 하면 링크드인은 그 주소록에만 접근할 수 있는 access token을 얻을 수 있게 되어서 다른 계정관련 정보랑 무관하게 딱 주소록만 받아올수가 있게 되는 거시다. Google 계정으로 링크드인에 로그인하기? 그것과는 아예 다른 이야기다. OpenID . whojes.com 이라는 멋진 사이트가 있다. 여기 사이트의 내 계정에 접근하는 방법, 즉 인증(Authentication)을 받는 방법은 전통적으로 whojes.com에 등록한 내 아이디와 패스워드를 입력하는 방법이다. 근데 모든 사이트마다 다 아이디/비밀번호를 제출하고 관리하는게 굉장히 귀찮단 말이야. 어디는 패스워드 규칙도 다르고 어디는 아이디 규칙도 다르고… 이를 해결하기 위해 OpenID Foundation 라는 비영리 단체가 나섰었다. OpenID는 사이트마다 아이디/비밀번호를 입력하고 계정에 접근하는 것보다, 공인된 IdP(Identity Provider, ex. google)에게 물어보는 것으로 Sign in을 대체하려고 했다. whojes.com에 아이디/비밀번호를 입력하기보다 IdP에게 물어보도록 하여 IdP가 나임을 인증해주면 whojes.com은 나의 계정에 접근할 수 있는 권한을 주는 것이 더 깔끔하고 중앙관리가 잘 될거같다 이거지. 그래서 OpenID Foundation은 이 인증 프로토콜을 전파하고 Identity Provider를 해 줄 놈들을 모집하고 OpenID를 많이 지원해달라 하고 실제로 많이 성장하는 듯 보였으나…. 딱 봐도, 네이버 아이디로 로그인 기능은 OAuth가 아니라 OpenID가 맞는 기능인거지. 인가의 문제가 아니라 인증의 문제인 것이다. 아니 그럼 네아로에서 구현한 OAuth는 뭘까? . 출처 네아로 . 물론 OAuth로도 authentication을 구현할 수 있다. ​access token을 받는데, 어떤 권한에 대해서 받냐면 내 개인정보를 볼 수 있는 권한에 대해서 토큰을 받아버리면 된다. whojes.com이 네이버 아이디로 로그인을 하려고 한다 치자. whojes.com은 oauth 때처럼 네이버 로그인창을 살짝 띄우고, 유저는 네이버로 로그인을 하고, 네이버는 유저에게 ‘whojes.com이 너의 이메일, 성별, 이름을 가져가려고 하는데 줄까?’ 하고 물어보고, 그래! 하면 네이버는 그 정보를 주는게 아니라 그 정보를 볼 수 있는 access token을 주는 것이다. whojes.com은 네이버로부터 나라는 인증을 받은게 아니라, 나의 정보를 볼 수 있는 토큰을 받은 것이다. ​whojes.com은 충분히 추론할 수 있다. 네이버로 인증하라고 창을 띄워 줬더니 훌륭하게 토큰을 받아왔고, 그 토큰을 가지고 네이버에 물어보니 개인정보를 알 수 있었으니, 이거면 인증하기에 충분하다! 라고 추론을 하는 것이다. 이것은 정확한 의미의 Authentication은 아니다. 나임을 인증해주는것이 아니라, 유저 정보를 조회할 수 있는 토큰을 발급해줌 . OpenID Connect (OIDC) . 인가 프로토콜인 OAuth에 인증까지 얹어 제공하는 것이 바로 OIDC이다. OpenID 는 비영리단체에서 운영하는 “내가 아이디를 하나로 통합하겠다!” 하는 서비스이고, OpenID Connect 는 OAuth 프로토콜에 OpenID가 사용하는 인증 프로토콜을 얹은, OAuth의 강화버전이라고 할 수 있다. 즉, OpenID Connect 는 프로토콜이고, OpenID는 프로토콜이면서 동시에 이제는 잘 사용하지 않는 서비스다. 오해금지 (위키에도 가장 먼저 나오는 설명이 서로 혼동하지 말라는 문장) . OIDC 는 OAuth가 주는 access_token에 더불어 issuer의 claims가 포함된 id_token 도 같이 건네준다. access token은 내가 누군지, 어디서 발급받았는지에 대한 정보는 하나도 들어가 있지 않고 특정 정보에 접근할 권한이 있는지만 체크를 하기 때문에, OIDC 없이 인증을 하려면 위의 네아로처럼 해야한다. (이를 pseudo-authentiation using OAuth 라고 한단다. https://en.wikipedia.org/wiki/OAuth#OpenID_vs._pseudo-authentication_using_OAuth ) . ​ 구글로 로그인하기 기능이 이를 충실히 설명해 놓았다. OAuth 로 구현시 ID_TOKEN 도 발급이 되고, 이것이 인증정보로 바로 사용이 된다. 검색량 추이 . ",
    "url": "http://localhost:4000/develop/study/oidc",
    "relUrl": "/develop/study/oidc"
  },"47": {
    "doc": "plumbing commands",
    "title": "plumbing commands",
    "content": "porcelain and plumbing commands . &nbsp;&nbsp;Git 에는 두가지 타입의 명령어가 존재하는데, porcelain commands 와 plumbing commands 가 그것이다. porcelain 커맨드는 우리가 흔히 알고 있는 user level 의 커맨드들을 통칭하는 것이고, plumbing 커맨드는 low level 의 명령어를 말한다. low level 의 커맨드를 공부하는 것은 git 의 구조를 이해하는데 도움이 많이 된다. track 되고 있지 않은 test.sh 이라는 이름의 파일을 git에 추가하고 커밋하는 명령어를 보면 . // porcelain 명령어 :~$ git add test.sh :~$ git commit -m \"test.sh commit\" . 로 user level 에서는 표현할 수 있지만, plumbing commands 들로 표현하면 다음과 같다. // plumbing 명령어 :~$ git hash-object -w test.sh 4b31a2ba75e0a892e230088949eb08ce6d091ed2 :~$ git update-index --add test.sh :~$ git write-tree 0900f4103708966f97d2e0d5c079cba4ffa71a07 :~$ git commit-tree -p ${마지막 commit id} -m \"test.sh commit\" 0900f4103708966f97d2e0d5c079cba4ffa71a07 b14f6c92f4ec6345c52a06a3fec51d38d091ba4a :~$ git update-ref refs/heads/master b14f6c92f4ec6345c52a06a3fec51d38d091ba4a .   git은 새로이 파일시스템을 만들어 그 스냅샷을 commit 이라는 이름으로 기록한다. 이 git 의 파일시스템에서 디렉토리는 tree, 나머지 모든 파일은 blob (binary large object) 형태로 저장하고, Git 에서 이 모든 것, commit/tree/blob 에 tag 를 더해 4가지 오브젝트를 저장하고 있다. 저장의 형태는 해당 오브젝트의 sha1 해시값 (40자리 16진수 중 2자리 directory 에 38자리 파일 이름으로 관리하고 있다. ${git-project}/.git/objects 경로에서 확인할 수 있다.), 내용은 zlib 을 이용한 압축으로 관리된다. 처음에 추가된 파일을 git에서 관리할 수 있는 sha1 hash object 로 만들어서 저장(-w 옵션)한다. :~$ git hash-object -w test.sh 4b31a2ba75e0a892e230088949eb08ce6d091ed2 . 그리고 git staging 을 위해 index 에 추가한다. (현재 상태 index 는 .git/index 파일에 명시되어있다.) . :~$ git update-index --add test.sh . 이 후 git 에서 관리하는 파일시스템의 루트 트리를 저장한다. :~$ git write-tree . 이 때, 각 commit 오브젝트는 자신의 루트 트리의 해시를 갖고 있으므로 (commit-tree 명령어 사용 시에 루트 트리의 hash를 넣어준다.) 이 때 저장된 루트 트리는 현재 마지막 커밋의 루트 트리와는 다르다. 이 후에 commit-tree 명령어를 통해서 parent 커밋과 root tree 의 해시를 지정하여 새로운 커밋을 찍는다. // -p 옵션은 옵셔널 :~$ git commit-tree -p ${마지막 commit id} -m \"test.sh commit\" 0900f4103708966f97d2e0d5c079cba4ffa71a07 b14f6c92f4ec6345c52a06a3fec51d38d091ba4a . 그리고 마지막으로 git 의 포인터가 바라보고 있는 커밋을 바꿔준다. :~$ git update-ref refs/heads/master b14f6c92f4ec6345c52a06a3fec51d38d091ba4a . | git cat-file 명령어는 git 에서 관리하는 object 들의 정보/상태/종류/내용 등을 볼 수 있는 명령어이다. | . | git 에서 관리하는 objects 에 대한 정보 | . | type | size | content | . | tree | 트리 오브젝트의 용량을 bytes로 표시 | 하위에 포함하고 있는 tree/blob 의 list 객체에 대한 접근권한, 파일이름은 여기서 관리한다. | . | blob | 컨텐츠의 용량을 bytes로 표시 | 텍스트, 이미지, 음악 혹은 단순 이진 파일처럼 다양한 형식의 파일이 저장될 수 있다. 파일이름이나 파일형식은 blob에 저장되지 않는다. (포함하는 tree에서 저장) | . | commit | commit content의 용량을 bytes 로 표시 | parent commit, author(date), committer(date), tree hash, commit message 를 포함 | . 출처: git-scm 참조: storycompiler . ",
    "url": "http://localhost:4000/develop/git/plumbing",
    "relUrl": "/develop/git/plumbing"
  },"48": {
    "doc": "shutdown hook",
    "title": "shutdown hook",
    "content": "리눅스 환경에서 Jvm 은 SIGTERM 이 들어올 경우 graceful shutdown 을 진행한다. 셧다운이 되기 전에 실행할 코드를 넣을 수 있는데, 여기에 필요한 코드는 . Runtime.getRuntime().addShutdownHook(Thread { logger.info(\"your code here\") }) . spring boot 앱에서 어떤 셧다운 훅이 등록되었는지를 확인해보자. val clazz = Class.forName(\"java.lang.ApplicationShutdownHooks\") val field = clazz.getDeclaredField(\"hooks\") field.isAccessible = true val threads = field.get(clazz) as IdentityHashMap&lt;Thread, Thread&gt; . 여기서 threads 를 살펴보면 . | {LogManager$Cleaner@~} \"Thread[Thread-0,5,main]\" | {AbstracApplicationContext$1@~} \"Thread[SpringContextShutdownHook,5,main]\" | . 이렇게 두 개의 shutdown 훅이 등록되어 있다. (여기에 어플리케이션을 통째로 래핑하고 있는 apm 등을 사용하면 추가될 수도 있다.) . 첫번째 훅은 java.util.logging.LogManager$Cleaner쓰레드로, 자바 1.4에서 도입된.. 뭐.. 그런거고, 두번째 것이 spring boot 에서 등록한 훅이다. spring boot 프레임워크에서 개발을 할 때에 유저레벨에서 서버가 종료될 때 동작했으면 하는 코드가 있으면 ContextClosedEvent 이벤트를 리스닝해서 훅을 등록하는게 낫다. Runtime.getRuntime() 에 등록된 훅들이 실행될 때는 순서가 없기 때문에, spring boot context 에 등록하지 않고 따로 Runtime 에 등록을 해두게 되면 spring boot context 의 종료가 되기 전에 사용하는 모듈이 내려가버리는 불상사가 발생할 수도 있기 때문이다. apache shardingsphere 는 아파치에서 제공하는 샤딩 라이브러리인데, 여기서는 broadcasting table 에 대해 각각의 샤드로 쿼리를 날릴 때 자체적으로 쓰레드풀을 만들어서 쿼리를 날린다. 셧다운 훅이 왔을 때 그 스레드풀이 내려가는데, 요 동작이 java.lang.Runtime 에 직접 등록이 되어있다. 코드 . 그렇기 때문에, spring boot 를 사용하는 내 어플리케이션 코드에서는 디펜던시가 있는 JpaRepository 가 먼저 내려가기 전에 그 쓰레드풀이 먼저 내려가 버리는 상황이 종종 발생했고, 그로 인해 에러가 올라오고 있었다. 저 코드에서는 google guava 라이브러리의 MoreExecutors.addDelayedShutdownHook 를 사용하는데, 이름은 delayed shutdown 이지만 코드를 읽어보면 시간을 기다리고 shutdown 을 날리는게 아니라 우선 shutdown 을 하고 시간동안 기다리는 코드다. 해당 라이브러리에서 Runtime 에 등록하는 셧다운 훅 쓰레드를 참조할 방법도 없고, 등록을 막는 방법도 없어서 스프링 부트 안에서는 따로 해결할 방법이 없었다. 그래서 요 문제를 해결하기에는 다음과 같은 방법이 있다. | 오픈소스인 샤딩스피어 라이브러리를 포크해서 해당 부분만 고친 후에 빌드해서 사용 . | 옵션으로 주입받을 수 있게 하거나, Runtime 에 등록하는게 아니라 Closeable 을 상속한 후에 외부에서 호출할 수 있게 | 차후에 마이너 버그픽스도 귀찮아지기 때문에 포기 | . | 샤딩스피어 쪽에 이슈제기를 해서 고쳐지기를 바란다. | 메인 컨트리뷰터들이 중국인이라서 그런가 이슈 업을 해놨는데도 댓글조차 안달림(마상) | . | 리플렉션으로 셧다운 훅을 다 들고와서 저놈들만 빼서 제거 . | 당장은 제일 간단하지만 모두가 불만족하는 코드 | . | . 3번에 대해 코드를 보면 . val clazz = Class.forName(\"java.lang.ApplicationShutdownHooks\") val field = clazz.getDeclaredField(\"hooks\") field.isAccessible = true val threads = field.get(clazz) as IdentityHashMap&lt;Thread, Thread&gt; // 모두가 불만족하는 코드 val shardingSphereShutdownHooks = threads.map { it.key }.filter { it.name.startsWith(\"DelayedShutdownHook-for-\") } shardingSphereShutdownHooks.forEach { deferredHooks.add(it) Runtime.getRuntime().removeShutdownHook(it) } // shutdown handler 등록 @Bean fun shutdownHandler(): ApplicationListener&lt;ContextClosedEvent&gt; { return ApplicationListener { deferredHooks.forEach { it.start() } } // join 도 해서 기다려줘야함. 간단히 할려고 이렇게 씀 } . ",
    "url": "http://localhost:4000/develop/springboot/shutdown-hook",
    "relUrl": "/develop/springboot/shutdown-hook"
  },"49": {
    "doc": "미안해 컴퓨터야",
    "title": "미안해 컴퓨터야",
    "content": "그러니까, 이론적으로 이 코드는 ‘whojes’ 를 찍을 수 있는데, . func main(){ var a int b := &amp;a go func(){ for { *b = 1 } }() go func(){ for{ *b = 2 } }() for { if a == 1 &amp;&amp; a == 2 { fmt.Println(\"whojes\") } } } . 그러니까 a 는 1이면서 동시에 2일 수 있다는 건데, 현대 cpu 나 컴파일러중에 이런게 되게 하는게 있으려나? . ",
    "url": "http://localhost:4000/develop/etc/sorry-computers",
    "relUrl": "/develop/etc/sorry-computers"
  },"50": {
    "doc": "springboot",
    "title": "springboot 2.X.X",
    "content": " ",
    "url": "http://localhost:4000/develop/springboot#springboot-2xx",
    "relUrl": "/develop/springboot#springboot-2xx"
  },"51": {
    "doc": "springboot",
    "title": "springboot",
    "content": " ",
    "url": "http://localhost:4000/develop/springboot",
    "relUrl": "/develop/springboot"
  },"52": {
    "doc": "study",
    "title": "잡공부",
    "content": " ",
    "url": "http://localhost:4000/develop/study#%EC%9E%A1%EA%B3%B5%EB%B6%80",
    "relUrl": "/develop/study#잡공부"
  },"53": {
    "doc": "study",
    "title": "study",
    "content": " ",
    "url": "http://localhost:4000/develop/study",
    "relUrl": "/develop/study"
  },"54": {
    "doc": "2019-02 일본 도쿄",
    "title": "여행의 시작",
    "content": ". 1 . 늑대와 개는 DNA 염기서열이 약 0.04% 밖에 차이가 나지 않는다고 한다. 실제로 계통분류학 상에서 동일 종(Canis lupus.)으로 취급받고, 종의 하위분류인 아종까지 내려가서야 구분이 돼서 개는 Canis lupus familiaris, 한반도에 서식했던 늑대는 Canis lupus chanco가 된다. 덕분에 함께 여행했던 개를 무서워하는 친구는 길거리에서 산책하고 있는 개를 보면 늘 인상을 찌푸리며 문명사회의 길거리에 자꾸 회색늑대가 배회한다고 불만을 터뜨리고는 했다. 물론 나는 개와 늑대가 어마어마하게 다르다고 생각하지만 말이다. 한국인과 일본인의 DNA 염기서열의 차이는 얼마나 될까? 모든 사람(Homo sapiens sapiens)의 유전적 차이가 0.1% 이내라고 하니 아마도 한국인과 일본인의 유전적 차이는 늑대와 개의 그것과 비슷하리라 추측해도 무방하겠다. 말인즉슨, 한국인과 일본인은 개와 늑대만큼의 차이가 날 수도 있겠다는 뜻이다. 개와 늑대가 서로 다르다는 것은 개랑 늑대가 제일 잘 알지 않을까? 내가 미얀마인과 태국인을 구별하지 못하는 것처럼 다른 가까운 동남아 사람이라도 한국인과 일본인을 구별하지 못하겠지만, 내가 보기에 한국인과 일본인은 가까운 거리와는 다르게 참 멀리 떨어져 있는 것 같다. 이런 쓸데없는 이야기를 늘어놓는 이유는, 이번 여행을 통해 한국인과 일본인이 어마어마한 차이를 가지고 있다고 생각하게 됐기 때문이다. 물론 내가 본 사회 군상의 차이가 개별 개체의 유전적인 차이에서만 기인하는 것은 아닐 테지만, 역사가 어쨌고 사회가 어쨌든 간에 기본적으로 타고난 성격 자체가 개와 늑대의 타고난 성격 차이처럼 중요한 차이를 가지고 있으니까 이 정도의 차이가 나는 것이 아닌가 싶다. 사실상 일본이라는 나라는 한국/중국/러시아/베트남 등이 가지고 있는 ‘기후와 위치와 역사 등에 따른 생활양식의 차이’ 수준의 차이가 아니라 그보다는 훨씬 기이한, 독자적으로 뻗어나가는 뭔가 다른 문화를 가지고 있다는 생각이 많이 들었다. 치와와와 회색늑대는 교배 가능하며, 그 자손도 생식기능이 있다. 2 . 뭐 가까운 나라치고 사이좋은 나라가 어디 있겠냐마는, 작금의 한일관계는 선진국 한정으로는 그 어느 인접국가들보다 관계가 안 좋다고 볼 수가 있겠다. 한일 각국의 정부가 부딪히는 거야 잃을 것이 많은 주체들의 싸움이므로 목도리도마뱀의 기세 싸움과 별 다를 바가 없어 정부 성향에 따라 총선 및 대선을 위한 내부 결집 등으로 사용될 수 있겠다만, 일본을 배제하려는 한국인의 정서는 친정부 혹은 반정부 성향과는 관계없이 해소되지 않은 일제 침략의 앙금으로부터 전해 내려오는 유구한 정서일 것이다. 3 . 도쿄에 가보기로 했다. 일본은 인생 처음으로 두 번 이상 방문한 국가로, 과거에 오사카를 한 번 방문한 적이 있었다. 나는 사실 일본어도 거의 아는 바 없고 일본 문화도 만화 서너 개를 본 정도에 지나지 않아 일본 문화에 대해 거진 문외한이라고 볼 수가 있고, 오사카를 방문했을 당시는 진짜 아무런 생각을 하지 않고 있던 시기라 오사카와 도쿄를 비교할 정도의 지식이 없기 때문에 이번이 첫 방문이라 생각하고 글을 쓰겠다. 애석하게도 여행기간 내내 우중충하고 때로는 비가 오는 날씨가 지속됐다. 일본과 한국은 서로 지진과 미세먼지를 막아주는 상호 필터 작용을 하고 있기에 맑고 청명한 푸른 하늘을 기대했건만, 아쉽게 됐다. 우중충... ",
    "url": "http://localhost:4000/travel/asia/japan_1#%EC%97%AC%ED%96%89%EC%9D%98-%EC%8B%9C%EC%9E%91",
    "relUrl": "/travel/asia/japan_1#여행의-시작"
  },"55": {
    "doc": "2019-02 일본 도쿄",
    "title": "도쿄의 도로와 교통",
    "content": "일본 국민들은 우리나라 국민들에 비해 정치에 별 관심이 없다고 하는데, 나와 내 친구는 그에 대한 가장 큰 원인을 철도 시스템에 전가하기로 했다. 서울 같은 경우 어디는 서울메트로가, 어디는 서울 도시철도가, 어디는 또 코레일이 관리하는 식으로 되어있긴 하지만, 이용자는 그런 것쯤 알 필요 없고 탈 때 카드 한 번, 환승할 때 한 번, 내릴 때 한 번 찍으면 알아서 다 처리가 되기에 편하기가 이를 데가 없으나 도쿄는 그렇지가 않다. 카드 띡 찍고 목적지까지 편히 앉아 정치권을 생각할 수 있는 우리나라에 비해, 도쿄에서는 전철을 탈 때부터 환승하고 내릴 때까지 다른 생각을 할 겨를이 없이 오롯이 집중하고 있어야 길을 잃지 않는다. 심지어 종로 3가 5호선과 1호선처럼 도무지 같은 역이라고는 보기 힘들 정도로 멀리 떨어진 플랫폼마저 하나의 역 이름으로 퉁쳐버리는 심술보를 온갖 역에다가 심어놔서 안 그래도 일본어에 무지한 나 같은 초심자들을 골머리 썩게 만든다. 각종 덕후(이 단어가 신조어임에도 불구하고 다른 대체할 만한 적당한 단어가 보이지 않기에 계속 사용해야겠다.)가 판치는 일본이지만 그중에서도 철도 덕후가 상당히 많은 것으로 알고 있는데, 우리는 이 나라에서는 철도 덕후가 되지 않으면 철도를 제대로 탈 수 없다는 결론에 이르렀다. 나리타에 처음 내려 도쿄 도심으로 들어가는 전철을 타려는 데서부터 고생을 좀 했다. 같은 철로 하나를 다른 목적지와 다른 하차역을 가진 여러 종류의 기차들이 공유했고, 이름도 서로 비슷한 라인들이 지나갔는데, 뭐가 더 빠르고 어디를 경유하는지 이름으로는 도무지 알아챌 수 없는 에어포트 쾌특, 쾌특, 특급, 에어포트 급행, 스카이라이너, 스카이액세스 등이 있었다. 최종적으로 우리가 탄 전철이 중간에 무슨 등급이 바뀌었다는 안내방송(친구는 일본어를 잘 구사하여 곧잘 해석해주곤 했다.)이 나오더니 갑자기 우리가 내려야 할 역들이 건너뛰는 역으로 바뀌기도 했다. 아인슈타인의 상대성 이론이 세상에 안겨준 충격이 이와 비슷했으리라. 아사쿠사바시 역에 간다고 했으면(나리타 공항의 역무원은 철도 덕후가 아니었나 보다.) 실제로도 가야지, 왜 갑자기 등급이 바뀌더니 안 가는지… 난 사실 아직까지도 내가 겪은 상황이 잘 이해가 가지 않는다. 이 정도로 복잡하게 해 놔야 국민들이 정치에 관심을 가지지 않나 보다. 나리타 공항에 내려서 마주한 도심 가는 전철 그림 . 친구는 전철에서 사용 가능한 교통카드가 있었으나 나는 없었으므로, 매 번 지하철을 탈 때마다 마그네틱 티켓을 뽑아서 가야 했다. 기본요금은 각 노선 전철의 운영 주체에 따라 상이했고 거리에 따라 대충 170~220엔 정도면 근처의 역들을 지나다닐 수 있었다. 가격 자체야 글쎄, 우리나라도 지하철이 현금가 1350원에 자주 타는 경기 시내버스는 1500원까지 올라갔으니, 이전만큼 큰 차이가 나지 않는 것 같다. 물론 우리나라의 급격한 물가상승 덕이겠지만. 전철 내부의 품질 자체는 서울의 그것과 큰 차이가 없었다. 도쿄의 거리에서는 무엇인지 모를 위화감이 느껴졌었는데, 우리는 그 위화감이 모든 건물의 건폐율이 지나치게 높다는 것에서부터 기인한다는 사실을 깨달았다. 대부분의 건물이 벽과 입구가 인도 혹은 차도에 딱 붙어있었고, 건물끼리의 사이 거리도 극도로 가까웠다. 서울의 건폐율 상한이 용도에 따라 50~70 퍼센트가 일반적이고 중심 상업지구에서만 예외적으로 90%를 허용해 주는 것에 반해, 도쿄에서 본 건물들은 주거지역이든 상업지구든 간에 건폐율이 거의 100퍼센트에 육박해 보였다. 이는 거리에 대해 깔끔하고 딱 들어찬 느낌도 들지만 동시에 답답함도 느끼게 돼서 기묘한 위화감을 안겨주었다. 긴자의 거리. 건물 사이의 간격, 건물과 도로 사이의 간격이 지나치게 작다. 도로가 매우 깨끗했다. 일본 여행을 가는 한국인들이 으레 도로가 정말 깨끗하다는 말을 했었지만 실제로 도로가 깨끗했을 경우에 어떤 이미지 일지는 잘 상상이 안 갔었는데, 거리가 깨끗하면 정말 좋다. 일반적으로 버려져 있는 담배꽁초, 캔 등도 매우 드물었을뿐더러 우리나라에 으레 있는 길거리 중간의 쓰레기 수거장소도 없고 불법주차 차량도 단 한대도 보지 못했다. 도로는 깨끗한 편이 좋은 것 같다. 도로 및 교통과는 별론으로, 지하철 내부에서 한국의 경제사학자 이영훈 교수의 반일 종족주의 라는 책이 일본 아마존에서 40만 권 완판에 추가 물량을 찍어내고 있다는 홍보 문구를 발견했다. 이 책의 광고를 일본 지하철에서 보다니! 가끔은 한국, 일본으로 갈라져 싸우는 것보다 민족주의냐 아니냐로 갈려서 싸우는 게 더 결집력 및 상대방에 대한 공격능력이 강화되지 않을까 생각한다. 한국 내 좌우합작의 결속력보다는 한일양국통합민족주의신당(가칭)이 결속력이 더 높지 않을까? 한국인 민족주의자와 일본인 민족주의자가 힘을 합친다는 것 자체가 어불성설이긴 하지만 말이다. 지하철 내에서 발견한 이영훈 교수의 책 반일 종족주의 홍보문구 . ",
    "url": "http://localhost:4000/travel/asia/japan_1#%EB%8F%84%EC%BF%84%EC%9D%98-%EB%8F%84%EB%A1%9C%EC%99%80-%EA%B5%90%ED%86%B5",
    "relUrl": "/travel/asia/japan_1#도쿄의-도로와-교통"
  },"56": {
    "doc": "2019-02 일본 도쿄",
    "title": "관광에 관하여",
    "content": "여행 기간 내 숙소는 아키하바라와 오카치마치 사이에 있는 작은 에어비앤비 숙소였다. 도쿄는 숙소 값이 정말 비쌌기 때문에 어쩔 수 없이 개인실 하나에 욕실 및 화장실은 공유하는 작은 숙소로 예약을 했는데, 중국에서도 그렇고 우리는 정말 숙소를 정하는 능력이 기묘하게 모자라다는 것을 다시금 깨닫게 되었다. 평균보다 조금 큰 체형이면 입장조차 하기 힘든 좁고 높은 계단으로 시작되는 숙소는 내 방 침대 옆 미등보다도 못한 조도의 조명만을 가지고 있었고, 복도에서는 며칠은 청소하지 않은 화장실에서 나는 강한 암모니아 향이 진동을 했다. 암모니아는 집중력 향상에 도움이 된다는 연구결과가 있으니 도쿄 여행 시 알찬 계획을 짤 때 도움을 주라는 숙소 측의 배려일지도 모르겠으나, 어둡기만 한 방은 내 친구의 심기를 불편하게 하기에 충분했다. 녀석은 태평양전쟁이 끝난 줄도 모른 채 필리핀의 섬에 숨어 살던 오노다 소위의 예시를 들면서, 이 숙소의 주인도 마찬가지로 아직도 등화관제를 시행하고 있는 것일지도 모른다고 투덜댔다. 숙소의 전경 . 도쿄에 관해 잘 아는 사람이라면 어떻게 생각할지 모르겠으나 내가 가지고 있던 지식으로는 도쿄 하면 아키하바라가 제일 먼저 떠올랐으므로, 첫 관광지는 아키하바라로 정했다. 나중에 깨닫게 된 사실이지만, 이 선택은 굉장히 후회되는 선택 중 하나가 됐다. 아키하바라처럼 자극적인 공간에 가게 되면 그다음 관광지는 뭐가 됐든 밋밋하고 평범해 보이게 되기 때문에, 혹여나 이 글을 보고 도쿄 여행을 결심한 사람이 있다면 아키하바라는 최후에 방문하길 바란다. 아키하바라의 Love merci 블록의 전경. 좋게 말하면 무슨 분야가 됐던 정말 그 분야의 가장 깊은 심연까지 가는 장인정신, 일본의 문화는 그것으로 요약할 수가 있겠다. 일본의 자부심 있는 장점이자 가치 있는 보물, 장인정신은 긍정적인 분야에서 나타날 때 그 진가가 발휘된다. 일본의 수많은 노포(老舗)들과 미쉐린의 평가조차 거절하는 전통 음식점들, 공방에서 수십수백 년 동안의 전통을 고수하며 실력을 발휘하는 장인들, 꿋꿋이 연구하여 수많은 노벨상을 배출하고 있는 동경대의 교수들 등이 그에 해당하겠다. 물론 그렇게 깊이 파내려 가는 것들 중엔 마냥 긍정적이지만은 않은 것도 꽤 있겠다. 대표적으로 대일본제국에 극한의 충성을 바친 나머지 죽음마저 조롱거리가 되어버린 카미카제 형님들이 계시겠고, 또 하나, 바로 아키하바라가 되시겠다. 아키하바라에 방문하기 전에 나는 비교적 온화한 문화 상대주의자로, 타 문화에 대하여 배타적인 모습을 보이거나 비하하는 생각을 전혀 하지 않았었다. 그러나 아키하바라, 특히 성적인 측면에서의 그 거대 역세권은 특별히 유별나서, 보는 이로 하여금 (나는 물론이거니와) 아무리 관대한 문화 상대주의자라도 본인의 신념을 포기하도록 유혹할 정도였다. 그곳에서 나는 ‘마니아라면 알 수 있다! 진짜의 향기! 착용 완료 로리 팬티 1000엔’이라고 적혀있는 자판기와 ‘뇌즙이 마구 나와… 녹는 듯한 촉감’이라고 적혀있는 전두엽 모양의 자위기구를 보고 이 놈들은 정말 갈 데까지 갔구나, 장인의 나라라 확실히 다르긴 다르다 하는 생각을 떨쳐버릴 수 없었다. 사실 방문 전에는 이미 많이 성적으로 개방이 된 우리나라의 성인용품샵과 그다지 다를 것이라고 생각하지 않았었는데, 역시 진짜는 진짜였다. 애니메이션 캐릭터가 그려진 베개들에는 특정 위치에 그 용도를 충분히 예상 가능한 구멍이 하나씩 뚫려 있는 것을 보고선 특정 문화는 어쩌면 다른 것이 아니라 틀린 것일 수도 있다는 생각이 스멀스멀 올라오는 신기한 경험을 했다. 도대체가 사진을 올릴 수가 없어서 안타까울 뿐이다 . 길거리든 어디든 애니메이션, 특히 모에화라고 불리는 모든 대상을 애니메이션 미소녀로 만들어버리는 그 일본의 문화는 유독 호불호가 강하게 갈리는 것 같다. 저런 문화를 좋아하지 않는 부류의 사람들이 보이는 본능적이고 즉각적인 거부감은 때때로 감출 수가 없어서, 거미나 원숭이 뇌를 먹는 사람을 볼 때 지어지는 표정이 얼굴에 즉각적으로 드러나기도 한다. 물론 이러한 태도를 보이는 사람들이 나타내는 거부감은 혐오를 조장하는 것이므로 전혀 바람직하지 않지만, 아키하바라 방문 후에는 그 부정적인 태도에 대해서도 어느 정도 이해가 가게 됐다. 방문했던 라디오회관에 있던 가장 은밀하지만 가장 사람이 붐볐던 공간에서는 각종 모에화된 모든 것들의 의상을 벗기는 행동들을 하고 있었고 그것을 확인하고 나서야 그들의 궁극적인 목표는 ‘옷을 벗기기(물리적으로)’ 임을 알아챌 수 있었다. 왜 모에화를 하냐? 옷을 벗기기 위해서. 커티스 르메이의 옷을 벗기는 것은 용납할 수 없지만 명찰에 커티스 르메이라고 적힌 미소녀를 벗기는 것은 용납이 가능한가 보다. 이 역시 사진을 올릴 수 없어 아쉬울 뿐이다. 커티스 르메이(!) 모에화, 소방관 모에화, 뭔지 모르겠는 차의 그림 충격받은 마음과 흔들리는 문화 상대주의에 대한 내 신념을 치료하기 위해 메이지 신궁을 방문했다. 메이지 신궁은 히로히토 덴노가 인간선언을 하기 전의 신격화된 황제 메이지 덴노가 죽고 나서 그를 기리기 위해 건설한 신궁이며, 태평양 전쟁 당시 일부 파손되었으나 전후 복건 되었다고 한다. 그러나 우람하고 굵은 나무들이 온전하게 쭉쭉 뻗어있는 것으로 미루어 볼 때 커티스 르메이의 도쿄 대공습은 상대적으로 꼼꼼하지 못하고 미진했음을 알 수 있었으며, 일본인들이 그를 모에화하여 옷을 벗기는 데에 크게 거부감이 없는 이유가 바로 르메이의 자비심 때문임이라고 생각할 수가 있겠다. 이 공간은 도쿄 도심 내부에서 가장 조용하고 한가로운 곳으로, 대도시 생활권에서 반드시 필요한 ‘휴식’을 제공할 수 있는 공간이라고 할 수 있겠다. 나는 이런 공간이 참 좋다. 메이지 신궁. 크고 고요하다. 남들은 대체 왜 가냐고 궁금해했지만, 나는 꼭 동경대에 한 번 방문해보고 싶었기에 잠깐 짬을 내서 들러 구경을 했다. 입구를 지나 들어가니 너무 만학도가 많아 일본은 초고령화에도 불구하고 그 학구열이 대단해 수많은 노벨상을 받기에 충분하다고 잠깐 생각하였으나, 그쪽은 동경대 의대 병원 쪽이었고 그들은 학생이 아니었음이 이내 밝혀졌다. 동경대는, 뭐랄까, 음… 고요한 학교였다. 일본의 대학은 3학기 제로 우리가 방문하였을 당시도 학기 중이었던 터라 무엇인가 대단한 것을 기대하였으나 실패하고 그냥 빠져나와야 했다. 아무래도 외적으로 드러나는 성공에 대한 욕심이 많이 꺾여가는 와중에 옛 마음을 되찾고자 하여, 고등학교 때 중간고사가 끝나고 친구들과 유수의 명문대들을 탐방하며 꿈을 키웠던 그때 그 마음가짐으로 동경대를 가게 된 것 같지만 아쉽게도 나이가 나이인지라 아무 생각이 들지 않았다. 배움에도 때가 있다는 옛 말이 떠오르는 방문이었다. 동경대의 사진 그 이후에도 롯폰기, 도쿄역(고쿄), 긴자, 신주쿠, 하라주쿠, 이케부쿠로 등을 방문하였으나, 솔직히 아키하바라를 경험한 직후에 방문했던 곳들이라 마약에 절여진 뇌마냥 다른 일반적인 자극에는 뇌가 반응을 하지 않는 수준이 되어버려 크게 감흥을 느끼지 못했다. 물론 서울과 비교해 다른 게 진짜 거의 없었기 때문에 그랬던 것일 수도 있다. 롯폰기 힐즈는 신도림 디큐브시티나 여의도 IFC몰 정도였고 긴자는 글쎄, 무역센터와 코엑스가 있는 영동대로 정도가 비슷했다. 하라주쿠는 사람이 바글바글 대는 게 사람 많은 명동에 온 기분이 났으며 신주쿠는 강남의 cgv 뒷골목 같았다. 그냥 다시 아키하바라로 갈까… 하다가, 아니야! 하고는 아! 사람이 마약에 절으면 이렇게 된다. 한 번 방문한 외국인인 나도 이 정돈데 현지인들은 어떤 느낌일까? . 신주쿠, 긴자, 롯폰기 힐즈의 어딘가에서 찍은 사진 . ",
    "url": "http://localhost:4000/travel/asia/japan_1#%EA%B4%80%EA%B4%91%EC%97%90-%EA%B4%80%ED%95%98%EC%97%AC",
    "relUrl": "/travel/asia/japan_1#관광에-관하여"
  },"57": {
    "doc": "2019-02 일본 도쿄",
    "title": "음식에 관하여",
    "content": "요즘도 그런지는 모르겠으나, 일본은 역시 대대로 식도락 여행지로 유명했던 것 같다. 아쉽게도, 미식가적인 면모는 내가 드물게 가지고 있는 미달점 중 하나라서 맛집 추천 같은 것은 없다. 다만 기억에 남는 몇 가지 음식이 있어 사진을 첨부하겠다. 신주쿠의 자우오(ざうお) 라는 식당에서는 직접 낚시질을 해서 생선을 낚아 요리를 해 먹을 수 있었다. 미운 우리 새끼라는 티브이 프로그램에서 나왔다고 하니 인터넷에서 쉽게 정보를 찾을 수 있다. 이 음식점에서는 사냥 및 수렵채집이 가능한 알파메일과 그렇지 않은 베타메일의 차이점이 가장 두드러지게 나타나는데, 베타메일은 자비로운 알파메일이 없으면 온전히 저녁을 굶을 수밖에 없고 가족들에게도 구박받을 수 있음을 여실히 느낄 수가 있다. 나는 다행히 다수의 낚시 경험을 바탕으로 한 마리의 큰 줄무니전갱이를 낚아 풍요로운 저녁식사에 보탬이 될 수 있었지만 같이 간 친구는 오랜 사냥 실패로 의욕을 잃고 있었기에 나는 알파메일의 또 하나의 덕목인 관대함으로 그에게 식사를 나누어주었다. 그는 나에게 부족한 지구력을 나의 약점으로 잡지 않고 보행 템포를 나에게 맞춰주는 자비로움으로 나에게 화답했다. 갓 잡은 줄무니전갱이로 만든 초밥과 사시미 . 쓰키지 시장에 방문했을 때, 사람이 바글바글했던 메인 거리에서 벗어나니 금방 작고 오래된 초밥집이 보여 방문했다. 일반 초밥집 중 일부는 한국인에게 와사비를 많이 넣어주는 등의 혜자스러움을 보여준다던데, 다행히 구글 후기에 따르면 그런 행태는 보여주지 않는 음식점으로 판단되어 방문했으며 결과적으로 수준 높고 만족스러운 식사를 즐길 수 있었다. 물론 이 정도 스시야는 한국에도 차고 넘치므로 그다지 특이할 만한 사항은 아니었다. 맛이 좋은 초밥! . 비가 와서 급하게 찾아 들어간 긴자의 모 음식점에서는 외국인이라고 무시하는 굉장히 불쾌한 경험도 마주할 수 있었다. 그들은 자릿세도 받았으면서 1인당 1 주문을 하기를 강요했으며 주기적으로 새로 음식을 시키길 요구했고, 폐점시간이 되기 2시간 전에 우리를 쫓아냈으며 이중결제를 하는 만행까지 저질렀다. 도쿄가 8번째 방문이었던 내 친구는 이런 경험은 처음이라며 극도로 분노했고, 같이 동행했던 지인들과 합세하여 구글 음식점 평점을 0.1점 낮추는 데 성공했다. 친구는 3개 국어를 이용해 그 음식점의 만행을 공표했고, 나는 그 음식점의 후기에 재방문 시 식탁에 대변을 보겠다는 엄포를 놓아 지금까지 좋아요 7개를 받는 데 성공했다. 아, 잘 모르겠다. 구글이 추천한 멋진 맛집들이었지만 그냥저냥 음식점들이었고, 특출 나게 맛이 있는 음식들은 아니었던 것 같다. 도쿄에 가면 찾아 먹겠지만, 이걸 먹으러 도쿄에 가지는 않을 것 같은 느낌의 그런 맛. 칭다오에서 경험한 음식은 굉장했었기 때문에 음식만으로도 그 부담스러운 입국비와 불쾌했던 입국 경험을 다시 감내할 각오도 어느 정도 되어있지만, 도쿄는 잘 모르겠다. 가격대가 너무 높아서 가성비를 찾을 수 없어 그런 것 같기도 하다. 텐동, 스키야키, 야끼도리의 사진. 음식사진 찍는데 재능이 없음을 잘 알겠다. Conclusion . 도쿄 여행은 아키하바라다. 아 아니 이게 아니지, 여행을 갔다 온 지가 꽤 시일이 지나 자극적이었던 아키하바라가 기억에 많이 남아서 그렇지, 도쿄 여행은 참 볼거리도 먹거리도 많은 여행지이다. 일본에 그다지 큰 관심이 없는 사람이라면 서울과 그다지 큰 차이를 느끼지 못할 수도 있으나, 식도락과 관광, 휴식 목적의 여행이 아니라 일본인과 한국인의 문화 차이를 만끽하며 그들의 특이성을 관찰하고자 하는 사람이라면 아주 좋은 여행지가 될 수 있겠다. ",
    "url": "http://localhost:4000/travel/asia/japan_1#%EC%9D%8C%EC%8B%9D%EC%97%90-%EA%B4%80%ED%95%98%EC%97%AC",
    "relUrl": "/travel/asia/japan_1#음식에-관하여"
  },"58": {
    "doc": "2019-02 일본 도쿄",
    "title": "2019-02 일본 도쿄",
    "content": " ",
    "url": "http://localhost:4000/travel/asia/japan_1",
    "relUrl": "/travel/asia/japan_1"
  },"59": {
    "doc": "여행",
    "title": "초심자의 여행기",
    "content": "여행을 잘 모릅니다. | 약간 무계획으로 다니는 스타일 | 여행에 별로 도움은 안됨 | . ",
    "url": "http://localhost:4000/travel#%EC%B4%88%EC%8B%AC%EC%9E%90%EC%9D%98-%EC%97%AC%ED%96%89%EA%B8%B0",
    "relUrl": "/travel#초심자의-여행기"
  },"60": {
    "doc": "여행",
    "title": "여행",
    "content": " ",
    "url": "http://localhost:4000/travel",
    "relUrl": "/travel"
  },"61": {
    "doc": "2017-08 베트남",
    "title": "여행의 시작",
    "content": "지정학적으로 중동 못지않게 고약한 곳에 위치한 덕에 아무리 지도를 펼쳐놓고 각을 재봐도 3박 4일 정도의 가벼운 여행을 떠날 수 있는 곳이 그렇게 많지가 않다. 지구 정복을 꿈꾸며 관광객에게 8만 원에 육박하는 입장료를 요구하는 시진핑의 중국, 루블화를 기축통화로 만들고 싶어 하는 푸틴의 러시아, 이웃들의 불화를 추구해 이득을 보려는 아베의 일본에 더불어 반지성 불법점거 테러단체 북조선에 이르기까지, 어째 가볍게 여행 가기 만만찮은 나라들로만 가득하다. 그나마 같은 자유주의 진영 하에서 동맹을 맺고 있던 일본과의 관계가 이지경이 났으니, 저 멀리 동남아로 눈을 돌려보는 수밖에. 육군훈련소에서 정훈교육 시간에 잠들지 않고 충실히 교육을 이수했다면 현재의 베트남은 월맹이 간첩을 적극 활용해 월남을 능욕하고 미군을 몰아낸 후 사회주의 공화국을 설립해 생긴 나라라는 것을 알 수 있다. 여행 초기에 한 때 적국이었던 대한민국 국민으로서 베트남 국민들을 대하는 것이 조금 껄끄러울 수도 있겠다고 생각했으나, 베트남 국민들은 우리나라가 패전국이라고 생각하고 있으므로 그런 생각은 접어두어도 좋다. 임무 미완 상태에서 종전을 위해 철수하는 것이 패전은 아니라고 생각하는 게 변명 같아 보일 수 있으나, 어찌 되었든 지금에서는 1인당 GDP가 대한민국이 베트남의 열 배가 넘으니 아무렇게나 생각하라지. 다낭의 미케비치에 누워서... ",
    "url": "http://localhost:4000/travel/asia/vietnam_1#%EC%97%AC%ED%96%89%EC%9D%98-%EC%8B%9C%EC%9E%91",
    "relUrl": "/travel/asia/vietnam_1#여행의-시작"
  },"62": {
    "doc": "2017-08 베트남",
    "title": "베트남의 숙소",
    "content": "베트남은 나라 전체가 공사판이라고 생각하면 될 것 같다. 공사장에서 공사를 하는 것이 아니라 그냥 삶에서 공사를 하고 있으므로, 두려운 사람이 잘 피하면서 다니도록 해야 한다. 우리는 베트남 입국 후 하이퐁Hải Phòng에서의 첫 밤을 4성급 호텔에서 묵었는데, 건물 내부가 공사판이었다. 보수공사가 아니라 건물 중간에 철제 계단을 놓는 대형공사를 하고 있었다. 뭔가 항의를 하려다 그냥 말았다. 한국과 베트남의 환율이 1:20이었으니 여기는 0.2성 정도라고 생각하면 마음의 짐이 조금은 덜어질 수 있겠다. 아침에 공사 소리에 잠을 깨 밖으로 나가보니.. 다낭에서는 에어비앤비를 통해 어디 외진 곳에 집 한 채를 통째로 빌려서 숙박을 했다. 한국인이라고는 코빼기도 보이지 않는 그곳에서 우리는 거대한 바퀴벌레들을 한 아름 보았다. 녀석들은 동남아의 따뜻하고 풍족한 기후 속에서 맛있는 것들만 골라서 많이 먹고 자랐는지 그 크기가 상당했다. 더운 나라 특성인지 국민성의 표출인지 모르겠으나 대부분의 집들이 대문뿐 아니라 집 내부의 문들을 활짝 열어놓은 상태였기에 골목과 내 집과의 경계선이 불분명한데, 그 골목길에서 무지막지한 녀석들을 대거 발견했으니 아무래도 나는 단잠에 빠질 수 없음을 직감했다. 그 숙소의 호스트였던 나이 지긋하신 할아버지는 연착으로 인해 늦어진 우리의 체크인을 받아주러 자정이 훌쩍 넘은 시간에 우리를 마중 나와주셨다. 월남전에 참전하셨었는지 유창한 영어를 구사하며 대한민국의 발전을 부러워하시던(그러나 나는 바퀴벌레를 피하느라 정신이 없어 제대로 대화를 진행하지 못했다.) 그 할아버지는 안타깝게도 열쇠를 가지고 오지 않으셨다. 열정이 넘치셨던 할아버지는 키를 가져올 수 있는 가족분에게 전화를 해 보시더니 피곤한 우리가 어서 쉬어야 한다면서 갑자기 집 담을 넘기 시작했다. 여든은 족히 되어 보이는 나이에 한밤중에 전깃줄로 범벅이 된 집 대문을 넘고 있는 할아버지의 모습을 보고 있자니 이게 미군의 침공을 이겨낸 국가의 평범한 국민인가 싶어 경외감이 들었다. 집 담을 넘고 계시는 할아버지 . 할아버지의 열정으로 우리는 일찍 숙소에 들어갈 수 있었고, 씻고 잠드려는 찰나 열쇠를 가진 가족분이 열쇠를 전달해 주러 오셨다. 바퀴벌레에 대한 걱정에 비해 숙소는 생각보다 퀄리티가 좋아 이내 단잠에 빠져들 수 있었다. 나는 그 숙소에 에어비앤비 평점 만점을 드렸고, 이내 우리도 최고의 숙박객이었다는 찬사를 들을 수 있었다. ",
    "url": "http://localhost:4000/travel/asia/vietnam_1#%EB%B2%A0%ED%8A%B8%EB%82%A8%EC%9D%98-%EC%88%99%EC%86%8C",
    "relUrl": "/travel/asia/vietnam_1#베트남의-숙소"
  },"63": {
    "doc": "2017-08 베트남",
    "title": "베트남의 음식",
    "content": "우리는 오만한 여행자였으므로, 트립 어드바이저를 위시한 다른 음식 리뷰 글들을 보고 음식점으로 들어가기보다는 그냥 시끌벅적한 음식점 하나를 잡아 들어가서 ‘분짜! 분짜!’를 외친 것이 음식 주문의 거의 대부분을 차지했다. 처음에는 이거 이거 하면서 손가락으로 이것저것 주문해 먹어보았으나, 이내 분짜와 넴이 최고라는 것을 알아채고야 말았다. 그 이후로는 음식점에 들어가 손가락 두 개를 펼친 후 분짜! 분짜! 넴! 넴! 만 하게 됐고 이내 우리 눈 앞에 맛 좋은 한 끼 식사가 눈앞에 차려졌다. 탄단지 균형이 완벽한 데다 맛도 가격도 불평하려야 불평할 수 없는 이놈의 분짜! 아, 또 먹고 싶다. 세상에서 제일 맛있는 분짜 . 뽀-응공! 초록색 택시 기사 아저씨한테 배운 ‘맛있는 쌀국수’라는 베트남 말이다. 현지인들이 보기엔 정신 나간 여행자 둘이 와서 분짜! 분짜! 뽀 응공! 뽀 응공! 하고 다녔으니 제법 한심해 보였으리라 생각한다. 그러나 그 맛을 본 이라면 마법의 주문마냥 입속에서 맴도는 그 매력적인 ‘응공!’을 거부하기 힘들 테다. 아, 하지만, 그 맛있는 음식을 조리한 조리도구는 되도록 쳐다보지 않는 편이 좋다. 다른 한류도 좋지만 먹거리 X파일 같은 플랫폼이 한번 대대적으로 베트남에 유행했으면 좋겠다는 생각을 했다. 대체적으로 위생 개념이 우리나라랑 비교해 약간 좋지 않기 때문에 밥을 먹고 있는데 옆에서 선풍기를 켜놓고 빗자루질을 하는 의도를 알 수 없는 행동을 하는 경우도 마주할 수 있기에 꽤 단단한 마음가짐이 요구된다. 뽀 응공! . 베트남은 세계 2위의 커피 생산지라고 한다. 환상적인 가성비를 자랑하는 G7 커피도 이미 우리나라에 명성을 낭낭하게 떨치고 있으며, 최근 편의점에서는 베트남식 콩카페 코코넛 라테를 파는 것도 발견했다. 그러나 내가 맛본 비엣남 제일의 커피는 역시 Highlands coffee의 메인 메뉴 Phin sua da라고 볼 수 있겠다. 베트남 특유의 필터링 기법으로 뽑아낸 커피와 연유의 조화로운 달콤 쌉싸름함이 일품이었다. 진정한 베트남의 맛을 본 나는 귀국 후 나는 곧바로 하이랜드 커피에 한국으로의 사업 진출을 요청하는 메일을 보냈으나, 답장으로 SMTP: 451, 4.30.0의 에러코드만 주야장천 받았으므로 이내 포기했다. 여건만 된다면 내가 직접 한국 지점을 내고 싶지만, 일개 소시민으로 살기도 버겁기에 작은 공이나 쏘아 올리며 그저 기다리기로 했다. Highlands coffee의 phin sua da . 중간에 들어간 베트남식 하나로마트에서는 저렴하고 이국적인 과일들이 굉장히 많았기에 종류를 불문하고 전부 하나씩 사 와서 먹어보았다. 맛만 보자면 용과, 망고, 망고스틴을 제외하면 사과, 배, 귤, 수박, 오렌지, 청포도 등이 압승이므로 그냥 ‘아! 나도 한 번씩은 먹어봤다!’ 정도의 의의만을 가지게 됐다. 베트남 자몽 buoi는 일반 자몽에 비해 맛이 굉장히 좋았으나, 이 몹쓸 과일을 까먹겠다고 칼을 들고 설치다가 왼손 네 번째 손가락 끝을 약간 심하게 베이는 사고가 일어났다. 먼 이국 땅까지 날아와 자몽 하나 먹어보겠다고 피를 잔뜩 보고 있는 내가 문득 서러웠지만, 이런 위생상태에서 혹여나 2차 감염의 우려가 있지는 않을까 헐레벌떡 호텔 로비로 달려가 블러드! 밴드! 허리 업! 을 외치며 직원을 찾았다. 다행히 4성급 호텔에 걸맞게 확실한 emergency 대응 체계가 있어 보였으며, 나는 소독제와 지혈제, 붕대를 획득하여 방으로 올라와 나머지 자몽을 해치울 수 있었다. 베트남식 과일가게 . 그 외에 넴, 반미 버거, 짜조 등 굉장히 괜찮고 저렴한 음식들을 많이 맛볼 수 있어 식도락 여행지로도 상당히 괜찮다는 평을 내릴 수 있었다. ",
    "url": "http://localhost:4000/travel/asia/vietnam_1#%EB%B2%A0%ED%8A%B8%EB%82%A8%EC%9D%98-%EC%9D%8C%EC%8B%9D",
    "relUrl": "/travel/asia/vietnam_1#베트남의-음식"
  },"64": {
    "doc": "2017-08 베트남",
    "title": "관광에 관하여",
    "content": "베트남의 도로 . 베트남에는 오토바이가 많다. 그리고 도로 규칙도 우리나라와 약간 다르다. 우선 경적을 울리는 것은 ‘너에게 불만이 있다’가 아니라 ‘내가 여기에 있다’라는 뜻이므로, 누가 자꾸 나한테 경적을 울리는 것 같아도 별거 아니니 신경 쓰지 말고 같이 경적을 계속 눌러주면 된다. 중앙선, 차선, 신호등은 다른 나라에서 해놓으니깐 해놓은 것일 뿐 별 다른 의미는 없어 보인다. 특히 지방 소도시에서 그 경향이 심한데, 1차로에서 우회전하고 3차로에서 좌회전하고 가끔 역주행도 하고, 빵빵 거리면서 하기만 하면 아무 문제없다. 나 여기 있는 거 너네가 알기만 하면 돼 라는 마인드로 아무렇게나 운전하면 된다. 충격적이게도 모두가 잠든 새벽 2시에 공항에서 에어비앤비 숙소로 가는 왕복 4차선 일반 도로에서 우리의 택시기사는 클락션에서 손을 떼지 않은 채로 브레이크 없이 신호등을 무시하고 도로 끝까지 내달렸다. 우리네 도로에서 그 정도 소음을 내려면 배기량 6000cc 정도 되는 스포츠카가 필요한 반면 베트남에는 그냥 일반 차만 있으면 되니 가성비가 훌륭한 편이라고 볼 수 있다. 베트남의 시민 . 베트남 사람들은 영어를 잘 못한다. 이들 입장에서 영어는 패전국의 언어이므로 배울 당위가 전혀 없는데도 우리는 굳이 영어로 질문을 했는데, 이는 우리가 오만한 여행자이기도 했지만 아무래도 역시 베트남도 다른 3세계 국가들과 마찬가지로 기축통화인 달러화를 자국 화폐 못지않게 좋아하기 때문이었다. 어느 정도 영어를 하는 편이 본인들 관광수입에도 도움이 될 것이기에 다낭, 하노이 등에서 관광 장사를 하는 사람들은 어느 정도 영어를 구사했는데(이 사람들도 dollor를 달러로 발음하면 잘 못 알아듣고 ‘또-라’라고 발음해야 한다.), 이들을 제외한 일반 시민들은 영어를 아예 알아듣지 못했다. yes, no를 못 알아듣는 정도니 yes라고 말만 하지 말고 고개를 열심히 끄덕거리면서 yes를 해야 대화를 진행할 수 있었다. Thanks 도 못 알아들으니, 누군가에게 도움을 받게 되면 까몬 까몬(cam on) 해주고 셀카나 같이 찍자고 하면 된다. 구글 트랜슬레이터를 열심히 활용하도록 하는 것이 좋다. 조만간 언어의 장벽을 허물 날이 오겠지? . 호객행위를 하는 사람들은 늘 조심해야 한다. 우리는 여행 전에 어떤 블로그에서 ‘베트남의 초록색 택시는 호객행위를 하지 않는 택시’라는 글을 보고 첫 택시로 초록색 택시를 선택했다가 보기 좋게 15배의 바가지를 쓴 경험 때문에 호객행위에 대해 극도의 반감을 가지고 있는 상태였다. 캇바Cát Bà 섬으로 들어가려는 도중 자꾸 승선티켓을 우리에게 강매하려는 아주머니를 만났고, 안타깝게도 우리는 그녀가 호객 대장님이라는 사실을 모른 채 비키라고 가볍게 밀쳐버리는 만행을 저지르고야 말았다. 덕분에 베트남식 주먹감자도 먹고 삿대질도 받고 한 마디도 그 뜻을 알아들을 수는 없지만 대번에 욕임을 알 수 있는 베트남 말도 들을 수 있었다. 욕을 먼저 배우는 것이 타 국가의 언어에 가장 친숙하고 빠르게 다가갈 수 있는 방법임을 상기한다면 호객 대장님을 건드는 것도 그리 나쁜 선택은 아닐지도 모른다. 대신, 그 이후에는 그 지역 일대에서는 어떤 베트남 사람도 우리에게 접근하지 않게 되므로 계획에 차질이 생기는 것을 견딜 수 없는 사람이라면 그냥 공손히 거절하는 것이 좋겠다. 베트남의 풍경 . 깟바 섬에서 나오는 마지막 배 티켓을 가지고 배를 기다리고 있는데, 이 도무지 알 수 없는 모자란 놈들이 배 정원은 생각도 않고 티켓만 주야장천 팔았는지 배에 타려는 도중에 갑자기 자리가 없다고 쫓겨나 버렸다. 주변은 삽시간에 아비규환이 되어버렸다. 타려는 사람들과 못 타게 밀어내는 사람들, 배 안으로 안 들어가고 갑판 위를 정복해 버린 사람들과 확성기를 통해 뜻 모를 베트남 말로 고함을 지르는 사람들까지… 갑자기 분위기가 피란 상태가 되었고 전혀 상황판단을 할 수 없던 우리는 급변하는 혼란한 분위기 속에서 상황을 파악해보려 애쓰기 시작했다. 주변에 한국인은커녕 영어로 뭐 물어볼 수 있는 외국인도 없었던 우리는 마지막 배를 영문도 모른 채 보내야만 했고, 사태가 잠잠해진 후에야 옆에 있던 청년에게 무슨 일인지 구글을 통해 물어볼 수 있었다. 그가 말하길, 확성기를 통해 말하던 사람이 배 한 척을 더 보내준다고 기다리라고 했다고 했다는 것이다. 다음 비행기를 놓칠 판국이었으므로 배는 언제 오는지, 제시간에 떠날 수 있는 것인지 전전긍긍하며 자꾸 물어보던 우리에게 그 친구가 보여준 핸드폰에는 번역된 문구가 적혀있었다. | 저 멀리 백악관에서 배를 기다립니다. 마음의 평화. 베트남 아름답지요? | . 나는 바쁘게 살다보니 놓치고 살았던 모양인데, 하여튼 이 친구(28세, 경찰)들은 마음의 평화를 가지고 있었던 거지. 베트남 아름답지요? 네, 아름답습니다. 결국 마지막 배보다 약 1시간 늦게 배가 도착했고, 해질 무렵의 기가 막히는 하롱베이의 광경을 보면서 적당히 지각하고 적당히 배고픈 상태로 다음 비행기를 타러 공항으로 갈 수 있었다. Hạ Long . Summary . 공산권 국가는 일반적으로 선호하지 않지만, 베트남 같은 경우 싼 물가와 굉장히 맛이 좋았던 음식들, 썩 괜찮았던 시민들, 호찌민 할아버지의 사진을 제외하면 비교적 선전 문구가 없었단 점에서 상당히 만족스러운 여행지라고 볼 수 있겠다. 다만, 땀이 많은 내 체질 상 더운 계절에 더운 나라로 가는 것은 당분간 삼가도록 하기로 마음먹었다. 다음에 기회가 되면 호찌민을 위시한 월남의 본거지로 여행을 떠나보고 싶다. ",
    "url": "http://localhost:4000/travel/asia/vietnam_1#%EA%B4%80%EA%B4%91%EC%97%90-%EA%B4%80%ED%95%98%EC%97%AC",
    "relUrl": "/travel/asia/vietnam_1#관광에-관하여"
  },"65": {
    "doc": "2017-08 베트남",
    "title": "2017-08 베트남",
    "content": " ",
    "url": "http://localhost:4000/travel/asia/vietnam_1",
    "relUrl": "/travel/asia/vietnam_1"
  },"66": {
    "doc": "2019-10 블라디보스톡",
    "title": "여행의 시작",
    "content": ". 비록 서방세계에서는 준 동양 취급을 받는 러시아지만, 지속적인 민족 강제이주정책에 더불어 흐루쇼프 선생님이 맞은 미국 뽕, 고르바초프 선생님과 옐친 선생님의 개방 덕에 우리나라보다 더 동쪽에 있음에도 불구하고 유럽의 냄새 정도는 맡을 수 있는 도시가 있어 이참에 한 번 나도 유럽 땅을 밟아보자 하여 블라디보스톡으로 짧은 여행을 다녀오게 됐다. 찾아보다 보니 블라디보스톡은 제 n의 타국가 도시 류의 별명이 많은 것 같았다. 제4의 로마, 제2의 샌프란시스코, 제2의 라스베이거스 등 다른 나라를 돌아보며 부러웠던 도시가 많았던 러시아 연방의 마음은 내가 잘 알겠으니, 이제는 제2의 메시로 불렸던 선수들이 다 사라지고 없다는 것을 연방 정부가 알아줬으면 좋겠다. 처음 가보는 러시아의 첫인상은 기내식 샌드위치에서 바로 알 수 있었다. 기내 옆자리의 불쾌한 커플이 서로의 발을 쓰다듬어주기 시작할 무렵에 제공이 된 치킨 샌드위치는 그다지 만족스럽지가 않았다. 치킨 살과 야채 조금을 감싸고 있던 식빵은 집어 드는 순간 가루가 되어 바사삭 흩뿌려져 버렸고, 치킨 살은 기묘하게 매끈하고 물컹하여 살짝 고무 같은 식감을 주었다. 고르바초프 형님이 시장 개방과 동시에 다 처리해주셨을 것이라고 생각했던 이런 저품질의 제품이 아직도 널리 유통되고 있는 것으로 보아 생각보다 이 여행에서 보고 느끼는 게 많을 것이라는 생각이 문득 들었다. 아, 러시아! . 10월 초의 블라디보스톡 날씨는 11월 초의 서울 날씨와 비슷했다. 공기는 시원하고 건조했고, 하늘은 푸르고 구름 한 점 없었으며 바람은 잠잠해 여행하기 아주 딱 좋은 날씨였다. 빠크롭스키 성당 근처의 에어비앤비 숙소. 여러모로 완벽했다. ",
    "url": "http://localhost:4000/travel/europe/vladik_1#%EC%97%AC%ED%96%89%EC%9D%98-%EC%8B%9C%EC%9E%91",
    "relUrl": "/travel/europe/vladik_1#여행의-시작"
  },"67": {
    "doc": "2019-10 블라디보스톡",
    "title": "블라디보스톡의 교통",
    "content": "나는 블라디보스톡의 교통에 굉장히 큰 감명을 받았다. 처음에는 렌트를 하려 했으나, 여러 여행 후기에서 차를 빌리는 것은 추천하지 않는다는 글을 많이 봐 포기하기로 했었다. 이제 와서 하는 생각인데, 차를 빌렸으면 아마 박살 나지 않았을까? 도시를 계획할 당시 샌프란시스코를 벤치마킹했다고 하는데, 그에 걸맞게 중심부의 대부분 도로는 일방통행으로 되어있다. 그러나 차선은 벤치마킹하지 못했는지 차선이 없는 길도 많고, 있어도 러시아인 눈에는 잘 안 보이는 것도 많은 듯했다. 차선이 없는 일방통행 길은 아주 매력적이다. 어차피 서로 양보도 안 하는 마당에 다 같은 방향으로 수백 대의 차량이 차선 없이 달리다 보니 이게 공공도로인지 F1 경주인지 알 게 뭐냐. 굳이 큰돈 들여 F1 경기장 갈 필요 없이 블라디보스톡을 가면 범퍼 없고 흙먼지 가득한 차량들이 무섭게 경주를 하는 것을 저렴하게 관람할 수 있다. 러시아에서는 자동차의 외관에 신경을 쓰지 않는다. 불곰이 옆에서 들이받기라도 했는지 옆문이 열릴 것 같아 보이지도 않게 찌그러진 차들도 있는가 하면 언덕에서 몇 바퀴 구른 것처럼 온 차체가 고루고루 우그러져 있는 차들도 있었다. 다섯 대 중 한 대는 범퍼가 부서져 있으며 범퍼가 아예 없는 차도 종종 보이고, 헤드라이트가 없는 차도 있었으며 헤드라이트는 깨진 채 안에 딱 전구 하나만 꽂혀있는 차들도 있었다. 당장 나도 세차도 잘 안하고 범퍼 긁혀도 그러려니 하는데, 이런거 보면 앞으로도 한참 멀었다. 자동차 관리의 절정 자동차 좌우 핸들이 고정되어 있지 않다. 러시아 전체가 우측통행을 하고 있지만, 블라디보스톡에서는 차 수입은 그냥 있는 그대로 수입해서 쓰는 것 같다. 일본차는 우핸들이고, 한국이나 독일 등의 외제차는 좌핸들이다. 그러니까, 우측통행의 도로지만 핸들의 위치는 자기 멋대로라는 것이다. 오히려 일제 차가 훨씬 많아 우핸들이 도로의 대부분을 차지하고 있다. 우핸들이면서 우측통행을 하고 있는 것은 내내 묘한 위화감을 주었으나, 우측통행에서는 좌핸들이어야 한다는 나의 생각이 쓸데없는 고정관념이었음을 깨닫게 해주는 계기가 됐다. 우리는 러시아식 Uber인 maxim 어플을 여러 번 이용했는데, 마지막에 공항으로 가는 길에 탔던 프리우스의 운전자 Igor는 러시아식 운전이 어떤 것인지 제대로 보여주었다. 처음 차를 탔을 때부터 이상한 낌새를 느끼기는 했다. 그는 노래를 크게 틀어놓고 흥얼거리면서 운전 내내 핸드폰으로 어떤 여성과 문자를 끊임없이 했고, ‘굿바이 블라디보스톡! 하하하!’ 하고 갑자기 소리를 지르는가 하면 갑자기 도로 중간 무렵에 차를 세우고 우리에게 ‘차가 좀 막히는데 계속 갈까?’를 구글 번역기를 이용해서 물어보는 등 척 보기에도 비범한 행동들을 지속적으로 했다. 심한 체증으로 차가 도로에 멈춰있을 무렵, 사이렌을 울리는 경찰차 한 대가 1차로 안쪽으로 달려왔고 다른 차들이 다 비켜서 주고 있었다. 러시아인들도 공권력은 무서운가 보다 생각하고 있었는데, 이고르는 갑자기 경찰차 뒤에 딱 붙더니 경찰차로 인해 생긴 길을 얌체같이 따라가기 시작했다. 대부분의 차가 이고르 같은 짓을 하려고 시도했다. 경찰차 뒤로 끼어드려고 하는 차가 수십 대 있었지만 이고르는 한 번을 결국 한 번도 그 자리를 내주지 않았고, 우리는 왜 옆면이 우그러진 차들이 이렇게 많은지 알게 되었다. 이고르는 그 경쟁자들을 제칠 때마다 중얼중얼하더니 하하하 웃기를 반복했고, 경찰차가 우리 행선지랑 다른 곳으로 빠질 때에야 아쉬워하며 ‘스파씨바! 폴리스!’ 하고 크게 소리를 지르고는 핸들을 치며 웃었다. 미친놈… . 경찰차를 따라가는 얌체 운전자 Igor . ",
    "url": "http://localhost:4000/travel/europe/vladik_1#%EB%B8%94%EB%9D%BC%EB%94%94%EB%B3%B4%EC%8A%A4%ED%86%A1%EC%9D%98-%EA%B5%90%ED%86%B5",
    "relUrl": "/travel/europe/vladik_1#블라디보스톡의-교통"
  },"68": {
    "doc": "2019-10 블라디보스톡",
    "title": "블라디보스톡의 관광",
    "content": "러시아인 . 러시아인들은 대체로 엄청 험한 표정을 짓고 다닌다. 도착 첫날에는 날씨가 궂어 전체적인 분위기가 을씨년스러워 그런 줄 알았는데, 다음날 매우 화창하게 하늘이 개었음에도 불구하고 사람들의 표정은 극도로 화가 난 상태 그대로였다. 러시아 사람들은 처음 보는 사람이 웃으면 멍청하게 생각한다는 이야기를 들었는데, 그렇다고 화가 난 표정으로 돌아다닐 필요는 없는데 말이다. 가끔은 도로변에 가만히 서서 무서운 표정을 짓고 지나가는 사람들을 쳐다보는 남자들도 있었다. 카더라 통신에는 러시아의 결혼은 철저하게 서로의 손익을 따진다고 한다. 여자는 남자가 경제력을 잃으면 가차 없이 이혼하고, 남자는 더 젊고 매력적인 여자를 만나면 가차 없이 환승한다고 하니 이 얼마나 매정한 방식인지. 부족하면 도태되는 것이 딱 자연 그대로의 약육강식을 보는 것 같았다. 그래서 그런지 길거리나 음식점, 공원 등에는 아이와 엄마 단 둘만 있는 사람들이 정말 많았고, 이상하게 공공장소에서 같이 있는 여자의 엉덩이를 움켜쥐는 남자도 많이 보았다. 국민 정서의 차이로 생각하기로 했다. 관광 . 블라디보스톡은 매우 작은 도시이다. 관광객들이 가는 장소는 전부 정해져 있으며, 네이버 블로그에 다량 소개되어 한국인으로 가득한 장소들 이외에는 일본, 중국, 한국 여행객들이 고루 분포되어 있다. 일본인 관광객은 일본을 제외하면 거의 마주친 적이 없었던 것 같은데, 아마도 블라디보스톡은 일본인들에게도 나름 의미가 있는 관광지이기 때문이 아닐까 싶었다. 여행 중에 주변에 한국인이 많다는 것은 외국 느낌을 덜 들게 하므로 여행 시 기피하게 되는 조건이다. 애석하게도 대부분의 관광명소가 한국인으로 가득했고, 해당 장소가 러시아 관광지라는 것을 알 수 있게 하는 것이 없으므로 사실상 루스키 섬은 제주도, 해양공원은 속초, 아르바트 거리는 명동쯤 되는 느낌을 준다. 제주도나 속초쯤 되어 보이지만, 사실 유럽이다. 관광은 루스키 섬, 독수리 전망대, 아르바트 거리와 그 근처의 해양공원, 혁명광장, 빠크롭스키 성당 등으로 구성되어 있다. 많이 나열했지만 하루면 다 돌아볼 수 있다. 날씨도 좋고 풍경도 좋았지만 특출날 것은 없다고 생각했다. 일정을 마치고 여유를 즐기던 늦은 오후, 아르바트 거리의 한 기념품 가게에서 푸틴의 얼굴이 그려진 여권케이스를 사버리고 말았다. 강렬하게 쳐다보는 것이 멋들어져 보이는 데다 ‘블라지미르 블라지미로비치 뿌찐’이라는 이름이 이국적인 매력을 가지고 있는 것 같아 홧김에 사서 여권을 끼워놨다. 출국 심사관은 보고도 무시했지만 비행기 티켓팅 승무원은 여권을 보고 주변에 전파하며 나에게 엄지를 추켜올려주어 기분이 조금은 좋아졌다. 타국 원수의 얼굴을 여권 커버로 사용하는 것이 여권법에 저촉되지 않았으면 좋겠다. 블라지미르 뿌찐 . ",
    "url": "http://localhost:4000/travel/europe/vladik_1#%EB%B8%94%EB%9D%BC%EB%94%94%EB%B3%B4%EC%8A%A4%ED%86%A1%EC%9D%98-%EA%B4%80%EA%B4%91",
    "relUrl": "/travel/europe/vladik_1#블라디보스톡의-관광"
  },"69": {
    "doc": "2019-10 블라디보스톡",
    "title": "음식",
    "content": "블라디보스톡의 음식은 나에게 그다지 매력적이지 못했다. 가격도 저렴하긴 하지만 다른 훨씬 저렴한 나라들에 비할 바는 아니었다. 잦은 주 구성원의 변경과 강제 이주 등으로 지역 특색에 맞는 음식이 발전할 겨를이 부족했는지 딱히 블라디보스톡 혹은 프리모리예 지방만의 독특한 음식이랄 것이 별로 없어 그런 것일 수도 있겠다. 아니면 일반적으로 여행에서의 행동에 대해 독특한 의미를 부여하는 것을 좋아하는 내가 의미부여를 할 부분이 많이 없어서 그런 것이었을 수도 있다. 가령, 별다른 의미를 부여할 수 없는 모 수제버거집에 들르는 것보다는 ‘동유럽의 극동지방에서 맛보는 북유럽식 롯데리아의 버거’라는 의미를 부여할 수 있는 헤스 버거(핀란드의 패스트푸드 체인 매장)를 방문하는 것을 나는 더 선호한다. 그런 의미에서 나는 도착하자마자 북한 식당을 방문했다. 의미를 부여하기도 딱 좋고, 실제로 북한 사람과 북한 음식이 궁금하기도 했기 때문이다. 결론적으로는 아주 실망스러웠다. 북한 종업원들은 딱히 새터민들과 다를 게 없는 행동/말투를 가지고 있어 새롭지가 않았고, 북한 음식들은 서방세계에서 경쟁을 이겨내고 살아남은 조미료들이 얼마나 맛있는 것인지 알게 해 줄 뿐이었다. 그냥 내 400 루블이 북한의 비밀 민주화 단체의 운영 자금으로 흘러들어 갔을 것이라 자위하고 말았다. 북한식 랭면과 강냉이 온면 킹크랩과 독도 새우는 대하 및 영덕대게가 더 나았다. 가격은 물론 비할 바가 아니게 저렴하긴 하지만, 굳이 블라디보스톡까지 가서 먹을 만한 메리트는 없다, 이게 내 결론이다. 트립 어드바이저의 추천이었으므로 딱히 운 없이 맛이 좋지 않은 곳으로 갔던 것은 아니었을 확률이 높다. 킹크랩과 독도새우, 대게와 대하를 먹도록 하자. 지친 몸을 이끌고 들어갔던 카페에서 ‘구소련의 아침’이라는 독특한 메뉴를 발견해 얼른 시켜보았다. 여전히 KGB 요원에게 감시받는 듯한 느낌이 드는 출근길의 맛이라고 생각하고 시켰지만, 달달한 캐러멜 마끼아또의 맛이 나는 데다 위에는 마시멜로와 생크림이 올려져 있는 것으로 보아 ‘구소련의 아침’은 기나긴 냉전의 종말과 자유진영으로의 편입이 주는 달달함을 의미했나 보다. 91년 12월 27일 아침의 맛인 게지. 구소련의 아침 . ",
    "url": "http://localhost:4000/travel/europe/vladik_1#%EC%9D%8C%EC%8B%9D",
    "relUrl": "/travel/europe/vladik_1#음식"
  },"70": {
    "doc": "2019-10 블라디보스톡",
    "title": "기타",
    "content": ". | 공항에서 기차를 타고 블라디보스톡 역을 향해 가는데 옆에 보이는 풍경에 선로를 걸어가는 사람들이 있었다. 차를 타고 고속화도로를 가는데 어쩐지 그 옆에서 걸어가고 있는 사람들도 봤다. 왜 거기를 걷지? | 도로나 건물에서 확성기를 통해 러시아어 알림이 들려오면 어쩐지 콜 오브 듀티 게임의 황폐화된 독소전쟁의 붉은 광장이 떠올랐다. | 전문성 하나 없이 투어를 진행하는 사람들도 많아 불쾌했다. 러일전쟁이 왜 언제 일어났는지도 잘 모르면서 왜 러일전쟁 방공호를 지나는 투어 가이드를 하고 있지? | 토카렙스키 곶은 당시 체감온도가 6도였지만 그 바다에서 윈드서핑, 카이트서핑, 심지어는 수영을 하는 백인들도 있었다. 나는 약하다. | . ",
    "url": "http://localhost:4000/travel/europe/vladik_1#%EA%B8%B0%ED%83%80",
    "relUrl": "/travel/europe/vladik_1#기타"
  },"71": {
    "doc": "2019-10 블라디보스톡",
    "title": "맺으며….",
    "content": "사실상 러시아 꼬리의 맛만 보고 온 느낌이다. 명왕성 표면적에 달하는 면적을 가지고 있는 나라에서 작은 도시 하나 안에서 하루면 다 걸어 다녀 볼 수 있는 부분만을 보고 왔으니 당연히 그럴 테지… 왜인지 조만간 우크라이나 등의 구소련 국가들 및 러시아 메인 도시들을 둘러보고 싶은 생각이 들었다. 진짜 조금 있었지만 러시아인과 함께 있으면 무언가 반드시 재밌는 일이 벌어질 것만 같은 확신에 찬 기대감도 든다. 근시일 내에 러시아 및 동유럽을 여행할 수 있는 기회가 있으면 좋겠다. ",
    "url": "http://localhost:4000/travel/europe/vladik_1#%EB%A7%BA%EC%9C%BC%EB%A9%B0",
    "relUrl": "/travel/europe/vladik_1#맺으며"
  },"72": {
    "doc": "2019-10 블라디보스톡",
    "title": "2019-10 블라디보스톡",
    "content": " ",
    "url": "http://localhost:4000/travel/europe/vladik_1",
    "relUrl": "/travel/europe/vladik_1"
  }
}
